// Problem Reductions: A Mathematical Reference
#let graph-data = json("../src/reductions/reduction_graph.json")
#import "@preview/cetz:0.4.2": canvas, draw
#import "@preview/ctheorems:1.1.3": thmbox, thmplain, thmproof, thmrules
#import "lib.typ": g-node, g-edge, petersen-graph, house-graph, octahedral-graph, draw-grid-graph, draw-triangular-graph, graph-colors

#set page(paper: "a4", margin: (x: 2cm, y: 2.5cm))
#set text(font: "New Computer Modern", size: 10pt)
#set par(justify: true)
#set heading(numbering: "1.1")

#show link: set text(blue)

// Set up theorem environments with ctheorems
#show: thmrules.with(qed-symbol: $square$)

// === Example JSON helpers ===
// Load example JSON files generated by `make examples`.
// Unified schema: { source: { problem, variant, instance }, target: { ... }, overhead: [...] }
#let load-example(name) = json("examples/" + name + ".json")

// Load result JSON: { solutions: [{ source_config, target_config }, ...] }
#let load-results(name) = json("examples/" + name + ".result.json")

#let problem-schemas = json("../src/reductions/problem_schemas.json")

// Problem display names for theorem headers
#let display-name = (
  "MaximumIndependentSet": [Maximum Independent Set],
  "MinimumVertexCover": [Minimum Vertex Cover],
  "MaxCut": [Max-Cut],
  "KColoring": [$k$-Coloring],
  "MinimumDominatingSet": [Minimum Dominating Set],
  "MaximumMatching": [Maximum Matching],
  "TravelingSalesman": [Traveling Salesman],
  "MaximumClique": [Maximum Clique],
  "MaximumSetPacking": [Maximum Set Packing],
  "MinimumSetCovering": [Minimum Set Covering],
  "SpinGlass": [Spin Glass],
  "QUBO": [QUBO],
  "ILP": [Integer Linear Programming],
  "Satisfiability": [SAT],
  "KSatisfiability": [$k$-SAT],
  "CircuitSAT": [CircuitSAT],
  "Factoring": [Factoring],
  "KingsSubgraph": [King's Subgraph MIS],
  "TriangularSubgraph": [Triangular Subgraph MIS],
)

// Definition label: "def:<ProblemName>" — each definition block must have a matching label


// Generate theorem label from source/target names (uses full names for consistency)
#let reduction-label(source, target) = {
  label("thm:" + source + "-to-" + target)
}

// State for tracking which reduction rules are described in the paper
#let covered-rules = state("covered-rules", ())

// Extract reductions for a problem from graph-data (returns (name, label) pairs)
#let get-reductions-to(problem-name) = {
  graph-data.edges
    .filter(e => graph-data.nodes.at(e.source).name == problem-name)
    .map(e => (name: graph-data.nodes.at(e.target).name, lbl: reduction-label(graph-data.nodes.at(e.source).name, graph-data.nodes.at(e.target).name)))
    .dedup(key: e => e.name)
}

#let get-reductions-from(problem-name) = {
  graph-data.edges
    .filter(e => graph-data.nodes.at(e.target).name == problem-name)
    .map(e => (name: graph-data.nodes.at(e.source).name, lbl: reduction-label(graph-data.nodes.at(e.source).name, graph-data.nodes.at(e.target).name)))
    .dedup(key: e => e.name)
}

// Render a single reduction with link (uses context to skip broken links gracefully)
#let render-reduction-link(r) = {
  context {
    if query(r.lbl).len() > 0 { link(r.lbl)[#r.name] }
    else { r.name }
  }
}

// Render the "Reduces to/from" lines for a problem
#let render-reductions(problem-name) = {
  let reduces-to = get-reductions-to(problem-name)
  let reduces-from = get-reductions-from(problem-name)
  if reduces-to.len() > 0 or reduces-from.len() > 0 {
    block(above: 0.5em)[
    #set text(size: 9pt)
      #if reduces-to.len() > 0 [
        - Reduces to: #reduces-to.map(render-reduction-link).join(", "). \
      ]
      #if reduces-from.len() > 0 [
        - Reduces from: #reduces-from.map(render-reduction-link).join(", ").
      ]
    ]
  }
}

// Render a problem's JSON schema as a field table (subtle styling)
#let render-schema(name) = {
  let schema = problem-schemas.find(s => s.name == name)
  if schema == none { return }
  block(
    stroke: (left: 2pt + luma(180)),
    inset: (left: 8pt),
  )[
    #set text(size: 9pt)
    #table(
      columns: (auto, 1fr),
      inset: (x: 2pt, y: 3pt),
      align: (left, left),
      stroke: none,
      table.header(
        text(fill: luma(30), raw(name)),
      ),
      table.hline(stroke: 0.3pt + luma(200)),
      ..schema.fields.map(f => (
        text(fill: luma(60), raw(f.name)),
        text(fill: luma(60), raw(f.description))
      )).flatten()
    )
  ]
}

// Render a concrete example box from JSON data (unified schema)
#let reduction-example(data, caption: none, body) = {
  block(
    width: 100%,
    inset: (x: 1em, y: 0.8em),
    fill: rgb("#f0f7ff"),
    stroke: (left: 2pt + rgb("#4a86e8")),
  )[
    #if caption != none {
      text(weight: "bold")[Example: #caption]
      parbreak()
    }
    *Source:* #data.source.problem
    #h(1em)
    *Target:* #data.target.problem
    #if body != none { parbreak(); body }
  ]
}

#let theorem = thmplain("theorem", [#h(-1.2em)Rule], base_level: 1)
#let proof = thmproof("proof", "Proof")
#let definition = thmbox(
  "definition",
  "Definition",
  fill: rgb("#f8f8f8"),
  stroke: (left: 2pt + rgb("#4a86e8")),
  inset: (x: 1em, y: 0.8em),
  base_level: 1,
)

// Problem definition wrapper: auto-adds schema, reductions list, and label
#let problem-def(name, body) = {
  let lbl = label("def:" + name)
  let title = display-name.at(name)
  [#definition(title)[
    #body
    #render-schema(name)
    #render-reductions(name)
  ] #lbl]
}

// Find edge in graph-data by source/target names
#let find-edge(source, target) = {
  let edge = graph-data.edges.find(e => graph-data.nodes.at(e.source).name == source and graph-data.nodes.at(e.target).name == target)
  if edge == none {
    edge = graph-data.edges.find(e => graph-data.nodes.at(e.source).name == target and graph-data.nodes.at(e.target).name == source)
  }
  edge
}

// Build display name from a graph-data node (name + variant)
#let variant-display(node) = {
  let base = display-name.at(node.name)
  if node.variant.len() == 0 { return base }
  let parts = ()
  if "graph" in node.variant and node.variant.graph != "SimpleGraph" {
    parts.push(node.variant.graph)
  }
  if "weight" in node.variant {
    if node.variant.weight == "i32" { parts.push("weighted") }
    else if node.variant.weight == "f64" { parts.push("real-weighted") }
  }
  if "k" in node.variant { parts.push[$k$-ary] }
  if parts.len() > 0 { [#base (#parts.join(", "))] } else { base }
}

// Format overhead fields as inline text
#let format-overhead(overhead) = {
  let parts = overhead.map(o => raw(o.field + " = " + o.formula))
  [_Overhead:_ #parts.join(", ").]
}

// Unified function for reduction rules: theorem + proof + optional example
#let reduction-rule(
  source, target,
  example: false,
  example-caption: none,
  extra: none,
  theorem-body, proof-body,
) = {
  let arrow = sym.arrow.r
  let edge = find-edge(source, target)
  let src-disp = if edge != none { variant-display(graph-data.nodes.at(edge.source)) }
                 else { display-name.at(source) }
  let tgt-disp = if edge != none { variant-display(graph-data.nodes.at(edge.target)) }
                 else { display-name.at(target) }
  let src-lbl = label("def:" + source)
  let tgt-lbl = label("def:" + target)
  let overhead = if edge != none and edge.overhead.len() > 0 { edge.overhead } else { none }
  let thm-lbl = label("thm:" + source + "-to-" + target)
  // Derive example filename from source/target: "Source" → "source", then "source_to_target"
  let example-name = lower(source) + "_to_" + lower(target)

  covered-rules.update(old => old + ((source, target),))

  [
    #v(1em)
    #theorem[
    *(*#context { if query(src-lbl).len() > 0 { link(src-lbl)[#src-disp] } else [#src-disp] }* #arrow *#context { if query(tgt-lbl).len() > 0 { link(tgt-lbl)[#tgt-disp] } else [#tgt-disp] }*)* #theorem-body
    #if overhead != none { linebreak(); format-overhead(overhead) }
  ] #thm-lbl]

  proof[#proof-body]

  if example {
    let data = load-example(example-name)
    pad(left: 1.5em, reduction-example(data, caption: example-caption)[#extra])
  }
}

#align(center)[
  #text(size: 16pt, weight: "bold")[Problem Reductions: Models and Transformations]
  #v(0.5em)
  #text(size: 11pt)[Jin-Guo Liu#super[1] #h(1em) Xi-Wei Pan#super[1]]
  #v(0.3em)
  #text(size: 9pt)[#super[1]Hong Kong University of Science and Technology (Guangzhou)]
  #v(0.3em)
  #text(size: 10pt, style: "italic")[github.com/CodingThrust/problem-reductions]
  #v(1em)
]

#block(width: 100%, inset: (x: 2em, y: 1em))[
  *Abstract.* We present formal definitions for computational problems and polynomial-time reductions implemented in the `problem-reductions` library. For each reduction, we state theorems with constructive proofs that preserve solution structure.
]


// Table of contents
#outline(title: "Contents", indent: 1.5em, depth: 2)

#pagebreak()

= Introduction

A _reduction_ from problem $A$ to problem $B$, denoted $A arrow.long B$, is a polynomial-time transformation of $A$-instances into $B$-instances such that: (1) the transformation runs in polynomial time, (2) solutions to $B$ can be efficiently mapped back to solutions of $A$, and (3) optimal solutions are preserved. The library implements #graph-data.edges.len() reductions connecting #graph-data.nodes.len() problem types.

== Notation

We use the following notation throughout. An _undirected graph_ $G = (V, E)$ consists of a vertex set $V$ and edge set $E subset.eq binom(V, 2)$. For a set $S$, $overline(S)$ or $V backslash S$ denotes its complement. We write $|S|$ for cardinality. A _clique_ in $G$ is a subset $K subset.eq V$ where every pair of distinct vertices is adjacent: $(u, v) in E$ for all distinct $u, v in K$. A _unit disk graph_ is a graph where vertices are points on a 2D lattice and $(u, v) in E$ iff $d(u, v) <= r$ for some radius $r$; a _King's subgraph_ uses the 8-connectivity square grid with $r approx 1.5$. For Boolean variables, $overline(x)$ denotes negation ($not x$). A _literal_ is a variable $x$ or its negation $overline(x)$. A _clause_ is a disjunction of literals. A formula in _conjunctive normal form_ (CNF) is a conjunction of clauses. We abbreviate Independent Set as IS, Vertex Cover as VC, and use $n$ for problem size, $m$ for number of clauses, and $k_j = |C_j|$ for clause size.

= Problem Definitions <sec:problems>

Each problem definition follows this structure:

#block(
  inset: (x: 1em, y: 0.8em),
  fill: rgb("#f8f8f8"),
  stroke: (left: 2pt + rgb("#4a86e8")),
)[
  *Definition N (Problem Name).* Formal problem statement defining input, constraints, and objective.

  #block(
    stroke: (left: 2pt + luma(180)),
    inset: (left: 8pt),
  )[
    #set text(size: 9pt)
    #table(
      columns: (auto, 1fr),
      inset: (x: 6pt, y: 3pt),
      align: (left, left),
      stroke: none,
      table.header(text(fill: luma(30), raw("ProblemName"))),
      table.hline(stroke: 0.3pt + luma(200)),
      text(fill: luma(60), raw("field_name")), text(fill: luma(60), raw("Field description from JSON schema")),
    )
  ]

  #set text(size: 9pt, fill: luma(60))
  _Reduces to:_ ProblemA, ProblemB. \
  _Reduces from:_ ProblemC.
]

The gray schema table shows the JSON field names used in the library's data structures. The reduction links at the bottom connect to the corresponding theorems in @sec:reductions.



== Graph Problems

In all graph problems below, $G = (V, E)$ denotes an undirected graph with $|V| = n$ vertices and $|E|$ edges.

#problem-def("MaximumIndependentSet")[
  Given $G = (V, E)$ with vertex weights $w: V -> RR$, find $S subset.eq V$ maximizing $sum_(v in S) w(v)$ such that no two vertices in $S$ are adjacent: $forall u, v in S: (u, v) in.not E$.
]

#problem-def("MinimumVertexCover")[
  Given $G = (V, E)$ with vertex weights $w: V -> RR$, find $S subset.eq V$ minimizing $sum_(v in S) w(v)$ such that every edge has at least one endpoint in $S$: $forall (u, v) in E: u in S or v in S$.
]

#problem-def("MaxCut")[
  Given $G = (V, E)$ with weights $w: E -> RR$, find partition $(S, overline(S))$ maximizing $sum_((u,v) in E: u in S, v in overline(S)) w(u, v)$.
]

#problem-def("KColoring")[
  Given $G = (V, E)$ and $k$ colors, find $c: V -> {1, ..., k}$ minimizing $|{(u, v) in E : c(u) = c(v)}|$.
]

#problem-def("MinimumDominatingSet")[
  Given $G = (V, E)$ with weights $w: V -> RR$, find $S subset.eq V$ minimizing $sum_(v in S) w(v)$ s.t. $forall v in V: v in S or exists u in S: (u, v) in E$.
]

#problem-def("MaximumMatching")[
  Given $G = (V, E)$ with weights $w: E -> RR$, find $M subset.eq E$ maximizing $sum_(e in M) w(e)$ s.t. $forall e_1, e_2 in M: e_1 inter e_2 = emptyset$.
]

#problem-def("TravelingSalesman")[
  Given an undirected graph $G=(V,E)$ with edge weights $w: E -> RR$, find an edge set $C subset.eq E$ that forms a cycle visiting every vertex exactly once and minimizes $sum_(e in C) w(e)$.
]

#problem-def("MaximumClique")[
  Given $G = (V, E)$, find $K subset.eq V$ maximizing $|K|$ such that all pairs in $K$ are adjacent: $forall u, v in K: (u, v) in E$. Equivalent to MIS on the complement graph $overline(G)$.
]


== Set Problems

#problem-def("MaximumSetPacking")[
  Given universe $U$, collection $cal(S) = {S_1, ..., S_m}$ with $S_i subset.eq U$, weights $w: cal(S) -> RR$, find $cal(P) subset.eq cal(S)$ maximizing $sum_(S in cal(P)) w(S)$ s.t. $forall S_i, S_j in cal(P): S_i inter S_j = emptyset$.
]

#problem-def("MinimumSetCovering")[
  Given universe $U$, collection $cal(S)$ with weights $w: cal(S) -> RR$, find $cal(C) subset.eq cal(S)$ minimizing $sum_(S in cal(C)) w(S)$ s.t. $union.big_(S in cal(C)) S = U$.
]

== Optimization Problems

#problem-def("SpinGlass")[
  Given $n$ spin variables $s_i in {-1, +1}$, pairwise couplings $J_(i j) in RR$, and external fields $h_i in RR$, minimize the Hamiltonian (energy function): $H(bold(s)) = -sum_((i,j)) J_(i j) s_i s_j - sum_i h_i s_i$.
]

#problem-def("QUBO")[
  Given $n$ binary variables $x_i in {0, 1}$, upper-triangular matrix $Q in RR^(n times n)$, minimize $f(bold(x)) = sum_(i=1)^n Q_(i i) x_i + sum_(i < j) Q_(i j) x_i x_j$ (using $x_i^2 = x_i$ for binary variables).
]

#problem-def("ILP")[
  Given $n$ integer variables $bold(x) in ZZ^n$, constraint matrix $A in RR^(m times n)$, bounds $bold(b) in RR^m$, and objective $bold(c) in RR^n$, find $bold(x)$ minimizing $bold(c)^top bold(x)$ subject to $A bold(x) <= bold(b)$ and variable bounds.
]

== Satisfiability Problems

#problem-def("Satisfiability")[
  Given a CNF formula $phi = and.big_(j=1)^m C_j$ with $m$ clauses over $n$ Boolean variables, where each clause $C_j = or.big_i ell_(j i)$ is a disjunction of literals, find an assignment $bold(x) in {0, 1}^n$ such that $phi(bold(x)) = 1$ (all clauses satisfied).
]

#problem-def("KSatisfiability")[
  SAT with exactly $k$ literals per clause.
]

#problem-def("CircuitSAT")[
  Given a Boolean circuit $C$ composed of logic gates (AND, OR, NOT, XOR) with $n$ input variables, find an input assignment $bold(x) in {0,1}^n$ such that $C(bold(x)) = 1$.
]

#problem-def("Factoring")[
  Given a composite integer $N$ and bit sizes $m, n$, find integers $p in [2, 2^m - 1]$ and $q in [2, 2^n - 1]$ such that $p times q = N$. Here $p$ has $m$ bits and $q$ has $n$ bits.
]

// Completeness check: warn about problem types in JSON but missing from paper
#{
  let json-models = {
    let names = graph-data.nodes.map(n => n.name)
    let unique = ()
    for n in names { if n not in unique { unique.push(n) } }
    unique
  }
  let defined = display-name.keys()
  let missing = json-models.filter(n => n not in defined)
  if missing.len() > 0 {
    block(width: 100%, inset: (x: 1em, y: 0.5em), fill: rgb("#fff3cd"), stroke: (left: 3pt + rgb("#ffc107")))[
      #text(fill: rgb("#856404"), weight: "bold")[Warning: Missing problem definitions for:]
      #text(fill: rgb("#856404"))[ #missing.join(", ")]
    ]
  }
}

= Reductions <sec:reductions>

Each reduction is presented as a *Rule* (with linked problem names and overhead from the graph data), followed by a *Proof* (construction, correctness, variable mapping, solution extraction), and optionally a *Concrete Example* (a small instance with verified solution). Problem names in the rule title link back to their definitions in @sec:problems.

== Trivial Reductions

#let mvc_mis = load-example("minimumvertexcover_to_maximumindependentset")
#let mvc_mis_r = load-results("minimumvertexcover_to_maximumindependentset")
#let mvc_mis_sol = mvc_mis_r.solutions.at(0)
#reduction-rule("MinimumVertexCover", "MaximumIndependentSet",
  example: true,
  example-caption: [Petersen graph ($n = 10$): VC $arrow.l.r$ IS],
  extra: [
    Source VC: $C = {#mvc_mis_sol.source_config.enumerate().filter(((i, x)) => x == 1).map(((i, x)) => str(i)).join(", ")}$ (size #mvc_mis_sol.source_config.filter(x => x == 1).len()) #h(1em)
    Target IS: $S = {#mvc_mis_sol.target_config.enumerate().filter(((i, x)) => x == 1).map(((i, x)) => str(i)).join(", ")}$ (size #mvc_mis_sol.target_config.filter(x => x == 1).len()) \
    $|"VC"| + |"IS"| = #mvc_mis.source.instance.num_vertices = |V|$ #sym.checkmark
  ],
)[
  $S subset.eq V$ is independent iff $V backslash S$ is a vertex cover, with $|"IS"| + |"VC"| = |V|$.
][
  ($arrow.r.double$) If $C$ is a vertex cover, for any $u, v in V backslash C$, $(u, v) in.not E$, so $V backslash C$ is independent. ($arrow.l.double$) If $S$ is independent, for any $(u, v) in E$, at most one endpoint is in $S$, so $V backslash S$ covers all edges. _Variable mapping:_ Given VC instance $(G, w)$, create IS instance $(G, w)$ with identical graph and weights. Solution extraction: for IS solution $S$, return $C = V backslash S$. The complement operation preserves optimality since $|S| + |C| = |V|$ is constant.
]

#reduction-rule("MaximumIndependentSet", "MinimumVertexCover")[
  The complement $C = V backslash S$ of an independent set is a vertex cover. Same graph and weights; reverse of VC $arrow.r$ IS.
][
  Identical to the reverse direction: $S$ is independent iff $V backslash S$ is a cover, with $|"IS"| + |"VC"| = |V|$. _Solution extraction:_ for VC solution $C$, return $S = V backslash C$.
]

#reduction-rule("MaximumIndependentSet", "MaximumSetPacking")[
  Each vertex becomes a singleton set of its incident edges; non-adjacent vertices have disjoint edge sets. Reverse of Set Packing $arrow.r$ IS.
][
  _Variable mapping:_ Universe $U = E$ (edges), $S_v = {e in E : v in e}$, $w(S_v) = w(v)$. Independent vertices have no shared edges, so their edge sets are disjoint $arrow.r.double$ packing. _Solution extraction:_ for packing ${S_v : v in P}$, return IS $= P$.
]

#reduction-rule("MaximumSetPacking", "MaximumIndependentSet")[
  Construct intersection graph $G' = (V', E')$ where $V' = cal(S)$ and $(S_i, S_j) in E'$ iff $S_i inter S_j != emptyset$, with $w(v_i) = w(S_i)$. Max packing $equiv$ Max IS on $G'$.
][
  Overlapping sets become adjacent vertices; disjoint sets become non-adjacent. A packing (mutually disjoint) maps to an IS (mutually non-adjacent). _Variable mapping:_ Vertices $= {S_1, ..., S_m}$, edges $= {(S_i, S_j) : S_i inter S_j != emptyset}$, $w(v_i) = w(S_i)$. Solution extraction: for IS $I subset.eq V'$, return packing $cal(P) = {S_i : v_i in I}$.
]

#reduction-rule("MinimumVertexCover", "MinimumSetCovering")[
  Construct $U = {0, ..., |E|-1}$, $S_v = {i : e_i "incident to" v}$, $w(S_v) = w(v)$. Then $C$ is a cover iff ${S_v : v in C}$ covers $U$.
][
  Each vertex's edge set becomes a subset; the cover condition (every edge covered) maps to the covering condition (every universe element in some selected set). _Variable mapping:_ Universe $U = {0, ..., |E|-1}$ (edge indices), $S_v = {i : e_i "incident to" v}$, $w(S_v) = w(v)$. Solution extraction: for covering ${S_v : v in C}$, return VC $= C$.
]

#reduction-rule("MaximumMatching", "MaximumSetPacking")[
  Construct $U = V$, $S_e = {u, v}$ for $e = (u,v)$, $w(S_e) = w(e)$. Then $M$ is a matching iff ${S_e : e in M}$ is a packing.
][
  Each edge becomes a set of its endpoints; disjoint edges have disjoint endpoint sets. _Variable mapping:_ Universe $U = V$ (vertices), $S_e = {u, v}$ for $e = (u,v)$, $w(S_e) = w(e)$. Solution extraction: for packing ${S_e : e in P}$, return matching $= P$ (the edges whose endpoint sets were packed).
]

#reduction-rule("QUBO", "SpinGlass")[
  The inverse substitution $x_i = (s_i + 1)/2$ converts QUBO to Ising. Reverse of SpinGlass $arrow.r$ QUBO.
][
  Expanding $sum_(i,j) Q_(i j) (s_i+1)(s_j+1)/4$ gives $J_(i j) = -Q_(i j)/4$, $h_i = -(Q_(i i) + sum_j Q_(i j))/2$. _Solution extraction:_ $x_i = (s_i + 1)/2$.
]

#let sg_qubo = load-example("spinglass_to_qubo")
#let sg_qubo_r = load-results("spinglass_to_qubo")
#let sg_qubo_sol = sg_qubo_r.solutions.at(0)
#reduction-rule("SpinGlass", "QUBO",
  example: true,
  example-caption: [10-spin Ising model on Petersen graph],
  extra: [
    Source: $n = #sg_qubo.source.instance.num_spins$ spins, $h_i = 0$, couplings $J_(i j) in {plus.minus 1}$ \
    Mapping: $s_i = 2x_i - 1$ converts spins ${-1, +1}$ to binary ${0, 1}$ \
    Ground state ($#sg_qubo_r.solutions.len()$-fold degenerate): $bold(x) = (#sg_qubo_sol.target_config.map(str).join(", "))$ #sym.checkmark
  ],
)[
  The substitution $s_i = 2x_i - 1$ yields $H_"SG"(bold(s)) = H_"QUBO"(bold(x)) + "const"$.
][
  Expanding $-sum_(i,j) J_(i j) (2x_i - 1)(2x_j - 1) - sum_i h_i (2x_i - 1)$ gives $Q_(i j) = -4J_(i j)$, $Q_(i i) = 2sum_j J_(i j) - 2h_i$. _Variable mapping:_ Spin $s_i in {-1, +1}$ maps to binary $x_i in {0, 1}$ via $s_i = 2x_i - 1$. Solution extraction: for QUBO solution $bold(x)$, return spins $s_i = 2x_i - 1$. The reverse maps $x_i = (s_i + 1)/2$.
]

== Penalty-Method QUBO Reductions <sec:penalty-method>

The _penalty method_ @glover2019 @lucas2014 converts a constrained optimization problem into an unconstrained QUBO by adding quadratic penalty terms. Given an objective $"obj"(bold(x))$ to minimize and constraints $g_k (bold(x)) = 0$, construct:
$ f(bold(x)) = "obj"(bold(x)) + P sum_k g_k (bold(x))^2 $
where $P$ is a penalty weight large enough that any constraint violation costs more than the entire objective range. Since $g_k (bold(x))^2 >= 0$ with equality iff $g_k (bold(x)) = 0$, minimizers of $f$ are feasible and optimal for the original problem. Because binary variables satisfy $x_i^2 = x_i$, the resulting $f$ is a quadratic in $bold(x)$, i.e.\ a QUBO.

#let mis_qubo = load-example("maximumindependentset_to_qubo")
#let mis_qubo_r = load-results("maximumindependentset_to_qubo")
#reduction-rule("MaximumIndependentSet", "QUBO",
  example: true,
  example-caption: [IS on the Petersen graph ($n = 10$) to QUBO],
  extra: [
    *Source edges:* $= {#mis_qubo.source.instance.edges.map(e => $(#e.at(0), #e.at(1))$).join(", ")}$ \
    *QUBO matrix* ($Q in RR^(#mis_qubo.target.instance.num_vars times #mis_qubo.target.instance.num_vars)$):
    $ Q = #math.mat(..mis_qubo.target.instance.matrix.map(row => row.map(v => {
      let r = calc.round(v, digits: 0)
      [#r]
    }))) $
    *Optimal IS* (size #mis_qubo_r.solutions.at(0).source_config.filter(x => x == 1).len()):
    #mis_qubo_r.solutions.map(sol => {
      let verts = sol.source_config.enumerate().filter(((i, x)) => x == 1).map(((i, x)) => str(i))
      $\{#verts.join(", ")\}$
    }).join(", ")
  ],
)[
  Given $G = (V, E)$ with weights $w$, construct upper-triangular $Q in RR^(n times n)$ with $Q_(i i) = -w_i$ and $Q_(i j) = P$ for $(i,j) in E$ ($i < j$), where $P = 1 + sum_i w_i$. Then minimizing $f(bold(x)) = sum_i Q_(i i) x_i + sum_(i<j) Q_(i j) x_i x_j$ is equivalent to maximizing the IS objective.
][
  _Construction._ The IS objective is: maximize $sum_i w_i x_i$ subject to $x_i x_j = 0$ for $(i,j) in E$. Applying the penalty method (@sec:penalty-method):
  $ f(bold(x)) = -sum_i w_i x_i + P sum_((i,j) in E) x_i x_j $
  Reading off the QUBO coefficients: diagonal $Q_(i i) = -w_i$ (linear terms), off-diagonal $Q_(i j) = P$ for edges $i < j$ (quadratic penalty).

  _Correctness._ If $bold(x)$ has any adjacent pair $(x_i = 1, x_j = 1)$ with $(i,j) in E$, the penalty $P > sum_i w_i >= -sum_i Q_(i i) x_i$ exceeds the maximum objective gain, so $bold(x)$ is not a minimizer. Among independent sets ($x_i x_j = 0$ for all edges), $f(bold(x)) = -sum_(i in S) w_i$, minimized exactly when $S$ is a maximum-weight IS.
]

#reduction-rule("MinimumVertexCover", "QUBO")[
  Given $G = (V, E)$ with weights $w$, construct upper-triangular $Q$ with $Q_(i i) = w_i - P dot "deg"(i)$ and $Q_(i j) = P$ for $(i,j) in E$ ($i < j$), where $P = 1 + sum_i w_i$ and $"deg"(i)$ is the degree of vertex $i$.
][
  _Construction._ The VC objective is: minimize $sum_i w_i x_i$ subject to $x_i + x_j >= 1$ for $(i,j) in E$. Applying the penalty method (@sec:penalty-method), the constraint $x_i + x_j >= 1$ is violated iff $x_i = x_j = 0$, with penalty $(1 - x_i)(1 - x_j)$:
  $ f(bold(x)) = sum_i w_i x_i + P sum_((i,j) in E) (1 - x_i)(1 - x_j) $
  Expanding: $(1 - x_i)(1 - x_j) = 1 - x_i - x_j + x_i x_j$.
  Summing over all edges, each vertex $i$ appears in $"deg"(i)$ terms. The QUBO coefficients are: diagonal $Q_(i i) = w_i - P dot "deg"(i)$ (objective plus linear penalty), off-diagonal $Q_(i j) = P$ for edges. The constant $P |E|$ does not affect the minimizer.
]

#let kc_qubo = load-example("kcoloring_to_qubo")
#let kc_qubo_r = load-results("kcoloring_to_qubo")
#let kc_qubo_sol = kc_qubo_r.solutions.at(0)
#reduction-rule("KColoring", "QUBO",
  example: true,
  example-caption: [House graph ($n = 5$, $|E| = 6$, $chi = 3$) with $k = 3$ colors],
  extra: [
    #{
      let hg = house-graph()
      let fills = kc_qubo_sol.source_config.map(c => graph-colors.at(c))
      align(center, canvas(length: 0.8cm, {
        for (u, v) in hg.edges { g-edge(hg.vertices.at(u), hg.vertices.at(v)) }
        for (k, pos) in hg.vertices.enumerate() {
          g-node(pos, name: str(k), fill: fills.at(k), label: str(k))
        }
      }))
    }

    *Step 1 -- Encode colors as binary variables.* Each vertex $v in {0,...,4}$ gets $k = 3$ binary variables $(x_(v,0), x_(v,1), x_(v,2))$, where $x_(v,c) = 1$ means "vertex $v$ receives color $c$." This gives $n k = 5 times 3 = 15$ QUBO variables total, arranged as:
    $ underbrace(x_(0,0) x_(0,1) x_(0,2), "vertex 0") #h(4pt) underbrace(x_(1,0) x_(1,1) x_(1,2), "vertex 1") #h(4pt) dots.c #h(4pt) underbrace(x_(4,0) x_(4,1) x_(4,2), "vertex 4") $

    *Step 2 -- One-hot penalty.* Each vertex must receive _exactly one_ color, i.e.\ $sum_c x_(v,c) = 1$. The penalty $(1 - sum_c x_(v,c))^2$ is zero iff exactly one variable in the group is 1. With weight $P_1 = 1 + n = 6$, this contributes $Q_(v k+c, v k+c) = -6$ on the diagonal and $Q_(v k+c_1, v k+c_2) = 12$ between same-vertex color pairs. These are the $5 times 5$ diagonal blocks of $Q$.\

    *Step 3 -- Edge conflict penalty.* For each edge $(u,v) in E$ and each color $c$, both endpoints having color $c$ is penalized: $P_2 dot x_(u,c) x_(v,c)$ with $P_2 = P_1 slash 2 = 3$. The house has 6 edges, each contributing 3 color penalties $arrow.r$ 18 off-diagonal entries of value $3$ in $Q$.\

    *Step 4 -- Verify a solution.* The first valid 3-coloring is $(c_0, ..., c_4) = (#kc_qubo_sol.source_config.map(str).join(", "))$, shown in the figure above. The one-hot encoding is $bold(x) = (#kc_qubo_sol.target_config.map(str).join(", "))$. Check: each 3-bit group has exactly one 1 (valid one-hot #sym.checkmark), and for every edge the two endpoints have different colors (e.g.\ edge $0 dash 1$: colors $#kc_qubo_sol.source_config.at(0), #kc_qubo_sol.source_config.at(1)$ #sym.checkmark).\

    *Count:* #kc_qubo_r.solutions.len() valid colorings $= 3! times 3$. The triangle $2 dash 3 dash 4$ forces 3 distinct colors ($3! = 6$ permutations); for each, the base vertices $0, 1$ each have 3 compatible choices but share edge $0 dash 1$, leaving $3$ valid pairs.
  ],
)[
  Given $G = (V, E)$ with $k$ colors, construct upper-triangular $Q in RR^(n k times n k)$ using one-hot encoding $x_(v,c) in {0,1}$ ($n k$ variables indexed by $v dot k + c$).
][
  _Construction._ Applying the penalty method (@sec:penalty-method), the QUBO objective combines a one-hot constraint penalty and an edge conflict penalty:
  $ f(bold(x)) = P_1 sum_(v in V) (1 - sum_(c=1)^k x_(v,c))^2 + P_2 sum_((u,v) in E) sum_(c=1)^k x_(u,c) x_(v,c) $

  _One-hot expansion._ For each vertex $v$, using $x_(v,c)^2 = x_(v,c)$:
  $ (1 - sum_c x_(v,c))^2 = 1 - sum_c x_(v,c) + 2 sum_(c_1 < c_2) x_(v,c_1) x_(v,c_2) $
  This yields diagonal $Q_(v k+c, v k+c) = -P_1$ and intra-vertex off-diagonal $Q_(v k+c_1, v k+c_2) = 2 P_1$ for $c_1 < c_2$.

  _Edge penalty._ For each edge $(u,v)$ and color $c$, the term $P_2 x_(u,c) x_(v,c)$ contributes to $Q_(u k+c, v k+c) += P_2$ (with appropriate index ordering).

  In our implementation, $P_1 = P = 1 + n$ and $P_2 = P\/2$.

  _Solution extraction._ For each vertex $v$, find $c$ with $x_(v,c) = 1$.
]

#reduction-rule("MaximumSetPacking", "QUBO")[
  Equivalent to IS on the intersection graph: $Q_(i i) = -w_i$ and $Q_(i j) = P$ for overlapping sets $i, j$ ($i < j$), where $P = 1 + sum_i w_i$.
][
  Two sets conflict iff they share an element. The intersection graph has sets as vertices and edges between conflicting pairs. Applying the penalty method (@sec:penalty-method) yields the same QUBO as IS on this graph: diagonal rewards selection, off-diagonal penalizes overlap. Correctness follows from the IS→QUBO proof.
]

#reduction-rule("KSatisfiability", "QUBO")[
  Given a Max-$k$-SAT instance with $m$ clauses over $n$ variables, construct a QUBO that counts unsatisfied clauses. For $k = 2$, $Q in RR^(n times n)$ directly encodes quadratic penalties. For $k = 3$, Rosenberg quadratization introduces $m$ auxiliary variables, giving $Q in RR^((n+m) times (n+m))$.
][
  *Case $k = 2$.* Applying the penalty method (@sec:penalty-method), each 2-literal clause has exactly one falsifying assignment (both literals false). The penalty for that assignment is a quadratic function of $x_i, x_j$:

  #table(
    columns: (auto, auto, auto, auto),
    inset: 4pt,
    align: left,
    table.header([*Clause*], [*Falsified when*], [*Penalty*], [*QUBO contributions*]),
    [$x_i or x_j$], [$x_i=0, x_j=0$], [$(1-x_i)(1-x_j)$], [$Q_(i i) -= 1, Q_(j j) -= 1, Q_(i j) += 1$],
    [$overline(x_i) or x_j$], [$x_i=1, x_j=0$], [$x_i(1-x_j)$], [$Q_(i i) += 1, Q_(i j) -= 1$],
    [$x_i or overline(x_j)$], [$x_i=0, x_j=1$], [$(1-x_i)x_j$], [$Q_(j j) += 1, Q_(i j) -= 1$],
    [$overline(x_i) or overline(x_j)$], [$x_i=1, x_j=1$], [$x_i x_j$], [$Q_(i j) += 1$],
  )

  Summing over all clauses, $f(bold(x)) = sum_j "penalty"_j (bold(x))$ counts falsified clauses. Minimizers of $f$ maximize satisfied clauses.

  *Case $k = 3$ (Rosenberg quadratization).* For each clause $(ell_1 or ell_2 or ell_3)$, define complement variables $y_i = overline(ell_i)$ (so $y_i = x_i$ if the literal is negated, $y_i = 1 - x_i$ if positive). The clause is violated when $y_1 y_2 y_3 = 1$. This cubic penalty is reduced to quadratic form by introducing an auxiliary variable $a$ and the substitution $a = y_1 y_2$, enforced via a Rosenberg penalty with weight $M$:
  $ H = a dot y_3 + M (y_1 y_2 - 2 y_1 a - 2 y_2 a + 3a) $
  where $M = 2$ suffices. For any binary assignment, if $a = y_1 y_2$ the penalty term vanishes and $H = y_1 y_2 y_3$ counts the clause violation. If $a != y_1 y_2$, the penalty $M(dots.c) >= 1$ makes this suboptimal.

  Each clause adds one auxiliary variable (indices $n, n+1, ..., n+m-1$), so the total QUBO has $n + m$ variables. Solution extraction discards auxiliary variables: return $bold(x)[0..n]$.
]

#reduction-rule("ILP", "QUBO")[
  Given binary ILP: maximize $bold(c)^top bold(x)$ subject to $A bold(x) = bold(b)$, $bold(x) in {0,1}^n$, construct upper-triangular $Q = -"diag"(bold(c) + 2P bold(b)^top A) + P A^top A$ where $P = 1 + ||bold(c)||_1 + ||bold(b)||_1$.
][
  _Step 1: Normalize constraints._ Convert inequalities to equalities using slack variables: $bold(a)_k^top bold(x) <= b_k$ becomes $bold(a)_k^top bold(x) + sum_(s=0)^(S_k - 1) 2^s y_(k,s) = b_k$ where $S_k = ceil(log_2 (b_k + 1))$ slack bits. For $>=$ constraints, the slack has a negative sign. The extended system is $A' bold(x)' = bold(b)$ with $bold(x)' = (bold(x), bold(y)) in {0,1}^(n')$. For minimization, negate $bold(c)$ to convert to maximization.

  _Step 2: QUBO construction._ Applying the penalty method (@sec:penalty-method), combine objective and penalty:
  $ f(bold(x)') = -bold(c')^top bold(x)' + P sum_(k=1)^m (bold(a)'_k^(top) bold(x)' - b_k)^2 $
  where $bold(c)' = (bold(c), bold(0))$. Expanding the quadratic penalty:
  $ = bold(x)'^(top) A'^(top) A' bold(x)' - 2 bold(b)^top A' bold(x)' + ||bold(b)||_2^2 $
  Combining with $-bold(c')^top bold(x)'$ and dropping constants:
  $ Q = -"diag"(bold(c)' + 2P bold(b)^top A') + P A'^(top) A' $
  The diagonal contains linear terms; the upper triangle of $A'^(top) A'$ gives quadratic terms (doubled for upper-triangular convention).

  _Solution extraction._ Discard slack variables: return $bold(x)' [0..n]$.
]

#let qubo_ilp = load-example("qubo_to_ilp")
#let qubo_ilp_r = load-results("qubo_to_ilp")
#let qubo_ilp_sol = qubo_ilp_r.solutions.at(0)
#reduction-rule("QUBO", "ILP",
  example: true,
  example-caption: [4-variable QUBO with 3 quadratic terms],
  extra: [
    Source: $n = #qubo_ilp.source.instance.num_vars$ binary variables, 3 off-diagonal terms \
    Target: #qubo_ilp.target.instance.num_vars ILP variables ($#qubo_ilp.source.instance.num_vars$ original $+ #(qubo_ilp.target.instance.num_vars - qubo_ilp.source.instance.num_vars)$ auxiliary), 9 McCormick constraints \
    Optimal: $bold(x) = (#qubo_ilp_sol.source_config.map(str).join(", "))$ ($#qubo_ilp_r.solutions.len()$-fold degenerate) #sym.checkmark
  ],
)[
  McCormick linearization: for each product $x_i x_j$ ($i < j$) with $Q_(i j) != 0$, introduce auxiliary $y_(i j)$ with three linear constraints.
][
  _Diagonal terms._ For binary $x_i$: $Q_(i i) x_i^2 = Q_(i i) x_i$, which is directly linear.

  _Off-diagonal terms._ For each non-zero $Q_(i j)$ ($i < j$), introduce binary $y_(i j) = x_i dot x_j$ with McCormick constraints:
  $ y_(i j) <= x_i, quad y_(i j) <= x_j, quad y_(i j) >= x_i + x_j - 1 $
  These constraints enforce $y_(i j) = x_i x_j$ for binary variables.

  _ILP formulation._ Minimize $sum_i Q_(i i) x_i + sum_(i < j) Q_(i j) y_(i j)$ subject to the McCormick constraints and $x_i, y_(i j) in {0, 1}$.

  _Solution extraction._ Return the first $n$ variables (discard auxiliary $y_(i j)$).
]

#let cs_ilp = load-example("circuitsat_to_ilp")
#let cs_ilp_r = load-results("circuitsat_to_ilp")
#reduction-rule("CircuitSAT", "ILP",
  example: true,
  example-caption: [1-bit full adder to ILP],
  extra: [
    Circuit: #cs_ilp.source.instance.num_gates gates (2 XOR, 2 AND, 1 OR), #cs_ilp.source.instance.num_variables variables \
    Target: #cs_ilp.target.instance.num_vars ILP variables (circuit vars $+$ auxiliary), trivial objective \
    #cs_ilp_r.solutions.len() feasible solutions ($= 2^3$ valid input combinations for the full adder) #sym.checkmark
  ],
)[
  Each gate maps to linear constraints over binary variables; any feasible ILP solution is a satisfying circuit assignment.
][
  _Tseitin flattening._ Recursively assign an ILP variable to each expression node. Named circuit variables keep their identity; internal nodes get auxiliary variables.

  _Gate encodings_ (output $c$, inputs $a_1, ..., a_k$, all binary):
  - NOT: $c + a = 1$
  - AND: $c <= a_i$ ($forall i$), $c >= sum a_i - (k - 1)$
  - OR: $c >= a_i$ ($forall i$), $c <= sum a_i$
  - XOR (binary, chained pairwise): $c <= a + b$, $c >= a - b$, $c >= b - a$, $c <= 2 - a - b$

  _Objective._ Minimize $0$ (feasibility problem): any feasible solution satisfies the circuit.

  _Solution extraction._ Return values of the named circuit variables.
]

== Non-Trivial Reductions

#let sat_mis = load-example("satisfiability_to_maximumindependentset")
#let sat_mis_r = load-results("satisfiability_to_maximumindependentset")
#let sat_mis_sol = sat_mis_r.solutions.at(0)
#reduction-rule("Satisfiability", "MaximumIndependentSet",
  example: true,
  example-caption: [3-SAT with 5 variables and 7 clauses],
  extra: [
    SAT assignment: $(x_1, ..., x_5) = (#sat_mis_sol.source_config.map(str).join(", "))$ \
    IS graph: #sat_mis.target.instance.num_vertices vertices ($= 3 times #sat_mis.source.instance.num_clauses$ literals), #sat_mis.target.instance.num_edges edges \
    IS of size #sat_mis.source.instance.num_clauses $= m$: one vertex per clause $arrow.r$ satisfying assignment #sym.checkmark
  ],
)[
  @karp1972 Given CNF $phi$ with $m$ clauses, construct graph $G$ such that $phi$ is satisfiable iff $G$ has an IS of size $m$.
][
  _Construction._ For $phi = and.big_(j=1)^m C_j$ with $C_j = (ell_(j,1) or ... or ell_(j,k_j))$:

  _Vertices:_ For each literal $ell_(j,i)$ in clause $C_j$, create $v_(j,i)$. Total: $|V| = sum_j k_j$.

  _Edges:_ (1) Intra-clause cliques: $E_"clause" = {(v_(j,i), v_(j,i')) : i != i'}$. (2) Conflict edges: $E_"conflict" = {(v_(j,i), v_(j',i')) : j != j', ell_(j,i) = overline(ell_(j',i'))}$.

  _Correctness._ ($arrow.r.double$) A satisfying assignment selects one true literal per clause; these vertices form an IS of size $m$ (no clause edges by selection, no conflict edges by consistency). ($arrow.l.double$) An IS of size $m$ must contain exactly one vertex per clause (by clause cliques); the corresponding literals are consistent (by conflict edges) and satisfy $phi$.

  _Solution extraction._ For $v_(j,i) in S$ with literal $x_k$: set $x_k = 1$; for $overline(x_k)$: set $x_k = 0$.
]

#let sat_kc = load-example("satisfiability_to_kcoloring")
#let sat_kc_r = load-results("satisfiability_to_kcoloring")
#let sat_kc_sol = sat_kc_r.solutions.at(0)
#reduction-rule("Satisfiability", "KColoring",
  example: true,
  example-caption: [5-variable SAT with 3 unit clauses to 3-coloring],
  extra: [
    SAT assignment: $(x_1, ..., x_5) = (#sat_kc_sol.source_config.map(str).join(", "))$ \
    Construction: 3 base + $2 times #sat_kc.source.instance.num_vars$ variable gadgets + OR-gadgets $arrow.r$ #sat_kc.target.instance.num_vertices vertices, #sat_kc.target.instance.num_edges edges \
    #sat_kc_r.solutions.len() valid 3-colorings (color symmetry of satisfying assignments) #sym.checkmark
  ],
)[
  @garey1979 Given CNF $phi$, construct graph $G$ such that $phi$ is satisfiable iff $G$ is 3-colorable.
][
  _Construction._ (1) Base triangle: TRUE, FALSE, AUX vertices with all pairs connected. (2) Variable gadget for $x_i$: vertices $"pos"_i$, $"neg"_i$ connected to each other and to AUX. (3) Clause gadget: for $(ell_1 or ... or ell_k)$, apply OR-gadgets iteratively producing output $o$, then connect $o$ to FALSE and AUX.

  _OR-gadget$(a, b) arrow.bar o$:_ Five vertices encoding $o = a or b$: if both $a, b$ have FALSE color, $o$ cannot have TRUE color.

  _Solution extraction._ Set $x_i = 1$ iff $"color"("pos"_i) = "color"("TRUE")$.
]

#let sat_ds = load-example("satisfiability_to_minimumdominatingset")
#let sat_ds_r = load-results("satisfiability_to_minimumdominatingset")
#let sat_ds_sol = sat_ds_r.solutions.at(0)
#reduction-rule("Satisfiability", "MinimumDominatingSet",
  example: true,
  example-caption: [5-variable 7-clause 3-SAT to dominating set],
  extra: [
    SAT assignment: $(x_1, ..., x_5) = (#sat_ds_sol.source_config.map(str).join(", "))$ \
    Vertex structure: $#sat_ds.target.instance.num_vertices = 3 times #sat_ds.source.instance.num_vars + #sat_ds.source.instance.num_clauses$ (variable triangles + clause vertices) \
    Dominating set of size $n = #sat_ds.source.instance.num_vars$: one vertex per variable triangle #sym.checkmark
  ],
)[
  @garey1979 Given CNF $phi$ with $n$ variables and $m$ clauses, $phi$ is satisfiable iff the constructed graph has a dominating set of size $n$.
][
  _Construction._ (1) Variable triangle for $x_i$: vertices $"pos"_i = 3i$, $"neg"_i = 3i+1$, $"dum"_i = 3i+2$ forming a triangle. (2) Clause vertex $c_j = 3n+j$ connected to $"pos"_i$ if $x_i in C_j$, to $"neg"_i$ if $overline(x_i) in C_j$.

  _Correctness._ Each triangle requires at least one vertex in any dominating set. Size-$n$ set must take exactly one per triangle, which dominates clause vertices iff corresponding literals satisfy all clauses.

  _Solution extraction._ Set $x_i = 1$ if $"pos"_i$ selected; $x_i = 0$ if $"neg"_i$ selected.
]

#reduction-rule("KSatisfiability", "Satisfiability")[
  Every $k$-SAT instance is already a SAT instance (clauses happen to have exactly $k$ literals). The embedding is trivial.
][
  _Variable mapping:_ Identity — variables and clauses unchanged. _Solution extraction:_ identity.
]

#let sat_ksat = load-example("satisfiability_to_ksatisfiability")
#let sat_ksat_r = load-results("satisfiability_to_ksatisfiability")
#let sat_ksat_sol = sat_ksat_r.solutions.at(0)
#reduction-rule("Satisfiability", "KSatisfiability",
  example: true,
  example-caption: [Mixed-size clauses (sizes 1 to 5) to 3-SAT],
  extra: [
    Source: #sat_ksat.source.instance.num_vars variables, #sat_ksat.source.instance.num_clauses clauses (sizes 1, 2, 3, 3, 4, 5) \
    Target 3-SAT: $#sat_ksat.target.instance.num_vars = #sat_ksat.source.instance.num_vars + 7$ variables, #sat_ksat.target.instance.num_clauses clauses (small padded, large split) \
    First solution: $(x_1, ..., x_5) = (#sat_ksat_sol.source_config.map(str).join(", "))$, auxiliary vars are don't-cares #sym.checkmark
  ],
)[
  @cook1971 @garey1979 Any SAT formula converts to $k$-SAT ($k >= 3$) preserving satisfiability.
][
  _Small clauses ($|C| < k$):_ Pad $(ell_1 or ... or ell_r)$ with auxiliary $y$: $(ell_1 or ... or ell_r or y or overline(y) or ...)$ to length $k$.

  _Large clauses ($|C| > k$):_ Split $(ell_1 or ... or ell_r)$ with auxiliaries $y_1, ..., y_(r-k)$:
  $ (ell_1 or ... or ell_(k-1) or y_1) and (overline(y_1) or ell_k or ... or y_2) and ... and (overline(y_(r-k)) or ell_(r-k+2) or ... or ell_r) $

  _Correctness._ Original clause true $arrow.l.r$ auxiliary chain can propagate truth through new clauses.
]

#let cs_sg = load-example("circuitsat_to_spinglass")
#let cs_sg_r = load-results("circuitsat_to_spinglass")
#reduction-rule("CircuitSAT", "SpinGlass",
  example: true,
  example-caption: [1-bit full adder to Ising model],
  extra: [
    Circuit: #cs_sg.source.instance.num_gates gates (2 XOR, 2 AND, 1 OR), #cs_sg.source.instance.num_variables variables \
    Target: #cs_sg.target.instance.num_spins spins (each gate allocates I/O + auxiliary spins) \
    #cs_sg_r.solutions.len() ground states ($= 2^3$ valid input combinations for the full adder) #sym.checkmark
  ],
)[
  @whitfield2012 @lucas2014 Each gate maps to a gadget whose ground states encode valid I/O.
][
  _Spin mapping:_ $sigma in {0,1} arrow.bar s = 2sigma - 1 in {-1, +1}$.

  _Gate gadgets_ (inputs 0,1; output 2; auxiliary 3 for XOR) are shown in @tab:gadgets. Allocate spins per variable, instantiate gadgets, sum Hamiltonians. Ground states correspond to satisfying assignments.
]

#figure(
  table(
    columns: (auto, auto, auto),
    inset: 4pt,
    align: left,
    table.header([*Gate*], [*Couplings $J$*], [*Fields $h$*]),
    [AND], [$J_(01)=1, J_(02)=J_(12)=-2$], [$h_0=h_1=-1, h_2=2$],
    [OR], [$J_(01)=1, J_(02)=J_(12)=-2$], [$h_0=h_1=1, h_2=-2$],
    [NOT], [$J_(01)=1$], [$h_0=h_1=0$],
    [XOR], [$J_(01)=1, J_(02)=J_(12)=-1, J_(03)=J_(13)=-2, J_(23)=2$], [$h_0=h_1=-1, h_2=1, h_3=2$],
  ),
  caption: [Ising gadgets for logic gates. Ground states match truth tables.]
) <tab:gadgets>

#let fact_cs = load-example("factoring_to_circuitsat")
#let fact_cs_r = load-results("factoring_to_circuitsat")
#let fact-decode(config, start, count) = {
  let pow2 = (1, 2, 4, 8, 16, 32)
  range(count).fold(0, (acc, i) => acc + config.at(start + i) * pow2.at(i))
}
#let fact-nbf = fact_cs.source.instance.num_bits_first
#let fact-nbs = fact_cs.source.instance.num_bits_second
#reduction-rule("Factoring", "CircuitSAT",
  example: true,
  example-caption: [Factor $N = #fact_cs.source.instance.number$],
  extra: [
    Circuit: $#fact-nbf times #fact-nbs$ array multiplier with #fact_cs.target.instance.num_gates gates, #fact_cs.target.instance.num_variables variables \
    #fact_cs_r.solutions.len() solutions: #fact_cs_r.solutions.map(sol => {
      let p = fact-decode(sol.source_config, 0, fact-nbf)
      let q = fact-decode(sol.source_config, fact-nbf, fact-nbs)
      $#p times #q = #fact_cs.source.instance.number$
    }).join(" and ") #sym.checkmark
  ],
)[
  An array multiplier with output constrained to $N$ is satisfiable iff $N$ factors within bit bounds. _(Folklore; no canonical reference.)_
][
  _Construction._ Build $m times n$ array multiplier for $p times q$:

  _Full adder $(i,j)$:_ $s_(i,j) + 2c_(i,j) = (p_i and q_j) + s_"prev" + c_"prev"$ via:
  $ a := p_i and q_j, quad t_1 := a xor s_"prev", quad s_(i,j) := t_1 xor c_"prev" $
  $ t_2 := t_1 and c_"prev", quad t_3 := a and s_"prev", quad c_(i,j) := t_2 or t_3 $

  _Output constraint:_ $M_k := "bit"_k(N)$ for $k = 1, ..., m+n$.

  _Solution extraction._ $p = sum_i p_i 2^(i-1)$, $q = sum_j q_j 2^(j-1)$.
]

#let mc_sg = load-example("maxcut_to_spinglass")
#let mc_sg_r = load-results("maxcut_to_spinglass")
#let mc_sg_sol = mc_sg_r.solutions.at(0)
#let mc_sg_cut = mc_sg.source.instance.edges.filter(e => mc_sg_sol.source_config.at(e.at(0)) != mc_sg_sol.source_config.at(e.at(1))).len()
#reduction-rule("MaxCut", "SpinGlass",
  example: true,
  example-caption: [Petersen graph ($n = 10$, unit weights) to Ising],
  extra: [
    Direct 1:1 mapping: vertices $arrow.r$ spins, $J_(i j) = w_(i j) = 1$, $h_i = 0$ \
    Partition: $S = {#mc_sg_sol.source_config.enumerate().filter(((i, x)) => x == 1).map(((i, x)) => str(i)).join(", ")}$ vs $overline(S) = {#mc_sg_sol.source_config.enumerate().filter(((i, x)) => x == 0).map(((i, x)) => str(i)).join(", ")}$ \
    Cut value $= #mc_sg_cut$ ($#mc_sg_r.solutions.len()$-fold degenerate) #sym.checkmark
  ],
)[
  @barahona1982 Set $J_(i j) = w_(i j)$, $h_i = 0$. Maximizing cut equals minimizing $-sum J_(i j) s_i s_j$.
][
  Opposite-partition vertices satisfy $s_i s_j = -1$, contributing $-J_(i j)(-1) = J_(i j)$ to the energy. _Variable mapping:_ $J_(i j) = w_(i j)$, $h_i = 0$, spins $s_i = 2 sigma_i - 1$ where $sigma_i in {0, 1}$ is the partition label. _Solution extraction:_ partition $= {i : s_i = +1}$.
]

#let sg_mc = load-example("spinglass_to_maxcut")
#let sg_mc_r = load-results("spinglass_to_maxcut")
#let sg_mc_sol = sg_mc_r.solutions.at(0)
#reduction-rule("SpinGlass", "MaxCut",
  example: true,
  example-caption: [10-spin Ising with alternating $J_(i j) in {plus.minus 1}$],
  extra: [
    All $h_i = 0$: no ancilla needed, direct 1:1 vertex mapping \
    Edge weights $w_(i j) = J_(i j) in {plus.minus 1}$ (alternating couplings) \
    Ground state ($#sg_mc_r.solutions.len()$-fold degenerate): partition $S = {#sg_mc_sol.source_config.enumerate().filter(((i, x)) => x == 1).map(((i, x)) => str(i)).join(", ")}$ #sym.checkmark
  ],
)[
  @barahona1982 @lucas2014 Ground states of Ising models correspond to maximum cuts.
][
  _MaxCut $arrow.r$ SpinGlass:_ Set $J_(i j) = w_(i j)$, $h_i = 0$. Maximizing cut equals minimizing $-sum J_(i j) s_i s_j$ since $s_i s_j = -1$ when $s_i != s_j$.

  _SpinGlass $arrow.r$ MaxCut:_ If $h_i = 0$: direct mapping $w_(i j) = J_(i j)$. Otherwise, add ancilla $a$ with $w_(i,a) = h_i$.

  _Solution extraction._ Without ancilla: identity. With ancilla: if $sigma_a = 1$, flip all spins before removing ancilla.
]

#reduction-rule("KColoring", "ILP")[
  The $k$-coloring problem reduces to binary ILP with $|V| dot k$ variables and $|V| + |E| dot k$ constraints.
][
  _Construction._ For graph $G = (V, E)$ with $k$ colors:

  _Variables:_ Binary $x_(v,c) in {0, 1}$ for each vertex $v in V$ and color $c in {1, ..., k}$. Interpretation: $x_(v,c) = 1$ iff vertex $v$ has color $c$.

  _Constraints:_ (1) Each vertex has exactly one color: $sum_(c=1)^k x_(v,c) = 1$ for all $v in V$. (2) Adjacent vertices have different colors: $x_(u,c) + x_(v,c) <= 1$ for all $(u, v) in E$ and $c in {1, ..., k}$.

  _Objective:_ Feasibility problem (minimize 0).

  _Correctness._ ($arrow.r.double$) A valid $k$-coloring assigns exactly one color per vertex with different colors on adjacent vertices; setting $x_(v,c) = 1$ for the assigned color satisfies all constraints. ($arrow.l.double$) Any feasible ILP solution has exactly one $x_(v,c) = 1$ per vertex; this defines a coloring, and constraint (2) ensures adjacent vertices differ.

  _Solution extraction._ For each vertex $v$, find $c$ with $x_(v,c) = 1$; assign color $c$ to $v$.
]

#reduction-rule("Factoring", "ILP")[
  Integer factorization reduces to binary ILP using McCormick linearization with $O(m n)$ variables and constraints.
][
  _Construction._ For target $N$ with $m$-bit factor $p$ and $n$-bit factor $q$:

  _Variables:_ Binary $p_i, q_j in {0,1}$ for factor bits; binary $z_(i j) in {0,1}$ for products $p_i dot q_j$; integer $c_k >= 0$ for carries at each bit position.

  _Product linearization (McCormick):_ For each $z_(i j) = p_i dot q_j$:
  $ z_(i j) <= p_i, quad z_(i j) <= q_j, quad z_(i j) >= p_i + q_j - 1 $

  _Bit-position equations:_ For each bit position $k$:
  $ sum_(i+j=k) z_(i j) + c_(k-1) = N_k + 2 c_k $
  where $N_k$ is the $k$-th bit of $N$ and $c_(-1) = 0$.

  _No overflow:_ $c_(m+n-1) = 0$.

  _Correctness._ The McCormick constraints enforce $z_(i j) = p_i dot q_j$ for binary variables. The bit equations encode $p times q = N$ via carry propagation, matching array multiplier semantics.

  _Solution extraction._ Read $p = sum_i p_i 2^i$ and $q = sum_j q_j 2^j$ from the binary variables.
]

== ILP Formulations

The following reductions to Integer Linear Programming are straightforward formulations where problem constraints map directly to linear inequalities.

#reduction-rule("MaximumIndependentSet", "ILP")[
  The maximum-weight IS problem reduces to binary ILP with $|V|$ variables and $|E|$ constraints.
][
  _Construction._ Variables: $x_v in {0, 1}$ for each $v in V$. Constraints: $x_u + x_v <= 1$ for each $(u, v) in E$. Objective: maximize $sum_v w_v x_v$. _Solution extraction:_ $S = {v : x_v = 1}$.
]

#reduction-rule("MinimumVertexCover", "ILP")[
  The minimum-weight VC problem reduces to binary ILP with $|V|$ variables and $|E|$ constraints.
][
  _Construction._ Variables: $x_v in {0, 1}$ for each $v in V$. Constraints: $x_u + x_v >= 1$ for each $(u, v) in E$. Objective: minimize $sum_v w_v x_v$. _Solution extraction:_ $C = {v : x_v = 1}$.
]

#reduction-rule("MaximumMatching", "ILP")[
  The maximum-weight matching reduces to binary ILP with $|E|$ variables and $|V|$ constraints.
][
  _Construction._ Variables: $x_e in {0, 1}$ for each $e in E$. Constraints: $sum_(e in.rev v) x_e <= 1$ for each $v in V$. Objective: maximize $sum_e w_e x_e$. _Solution extraction:_ $M = {e : x_e = 1}$.
]

#reduction-rule("MaximumSetPacking", "ILP")[
  Set packing reduces to binary ILP with $|cal(S)|$ variables and at most $binom(|cal(S)|, 2)$ constraints.
][
  _Construction._ Variables: $x_i in {0, 1}$ for each $S_i in cal(S)$. Constraints: $x_i + x_j <= 1$ for each overlapping pair $S_i, S_j in cal(S)$ with $S_i inter S_j != emptyset$. Objective: maximize $sum_i w_i x_i$. _Solution extraction:_ $cal(P) = {S_i : x_i = 1}$.
]

#reduction-rule("MinimumSetCovering", "ILP")[
  Set covering reduces to binary ILP with $|cal(S)|$ variables and $|U|$ constraints.
][
  _Construction._ Variables: $x_i in {0, 1}$ for each $S_i in cal(S)$. Constraints: $sum_(S_i in.rev u) x_i >= 1$ for each $u in U$. Objective: minimize $sum_i w_i x_i$. _Solution extraction:_ $cal(C) = {S_i : x_i = 1}$.
]

#reduction-rule("MinimumDominatingSet", "ILP")[
  Dominating set reduces to binary ILP with $|V|$ variables and $|V|$ constraints.
][
  _Construction._ Variables: $x_v in {0, 1}$ for each $v in V$. Constraints: $x_v + sum_(u in N(v)) x_u >= 1$ for each $v in V$ (each vertex dominated). Objective: minimize $sum_v w_v x_v$. _Solution extraction:_ $D = {v : x_v = 1}$.
]

#reduction-rule("MaximumClique", "ILP")[
  Maximum clique reduces to binary ILP with $|V|$ variables and $O(|overline(E)|)$ constraints.
][
  _Construction._ Variables: $x_v in {0, 1}$ for each $v in V$. Constraints: $x_u + x_v <= 1$ for each $(u, v) in.not E$ (non-edges). Objective: maximize $sum_v x_v$. Equivalently, IS on the complement graph. _Solution extraction:_ $K = {v : x_v = 1}$.
]

#reduction-rule("TravelingSalesman", "ILP",
  example: true,
  example-caption: [Weighted $K_4$: the optimal tour $0 arrow 1 arrow 3 arrow 2 arrow 0$ with cost 80 is found by position-based ILP.],
)[
  The traveling salesman problem reduces to binary ILP with $n^2 + 2 m n$ variables via position-based encoding with McCormick linearization.
][
  _Construction._ For graph $G = (V, E)$ with $n = |V|$ and $m = |E|$:

  _Variables:_ Binary $x_(v,k) in {0, 1}$ for each vertex $v in V$ and position $k in {0, ..., n-1}$. Interpretation: $x_(v,k) = 1$ iff vertex $v$ is at position $k$ in the tour.

  _Auxiliary variables:_ For each edge $(u,v) in E$ and position $k$, introduce $y_(u,v,k)$ and $y_(v,u,k)$ to linearize the products $x_(u,k) dot x_(v,(k+1) mod n)$ and $x_(v,k) dot x_(u,(k+1) mod n)$ respectively.

  _Constraints:_ (1) Each vertex has exactly one position: $sum_(k=0)^(n-1) x_(v,k) = 1$ for all $v in V$. (2) Each position has exactly one vertex: $sum_(v in V) x_(v,k) = 1$ for all $k$. (3) Non-edge consecutive prohibition: if ${v,w} in.not E$, then $x_(v,k) + x_(w,(k+1) mod n) <= 1$ for all $k$. (4) McCormick: $y <= x_(v,k)$, $y <= x_(w,(k+1) mod n)$, $y >= x_(v,k) + x_(w,(k+1) mod n) - 1$.

  _Objective:_ Minimize $sum_((u,v) in E) w(u,v) dot sum_k (y_(u,v,k) + y_(v,u,k))$.

  _Solution extraction._ For each position $k$, find vertex $v$ with $x_(v,k) = 1$ to recover the tour permutation; then select edges between consecutive positions.
]

== Unit Disk Mapping

#reduction-rule("MaximumIndependentSet", "KingsSubgraph")[
  @nguyen2023 Any MIS problem on a general graph $G$ can be reduced to MIS on a unit disk graph (King's subgraph) with at most quadratic overhead in the number of vertices.
][
  _Construction (Copy-Line Method)._ Given $G = (V, E)$ with $n = |V|$:

  1. _Vertex ordering:_ Compute a path decomposition of $G$ to obtain vertex order $(v_1, ..., v_n)$. The pathwidth determines the grid height.

  2. _Copy lines:_ For each vertex $v_i$, create an L-shaped "copy line" on the grid:
  $ "CopyLine"(v_i) = {(r, c_i) : r in [r_"start", r_"stop"]} union {(r_i, c) : c in [c_i, c_"stop"]} $
  where positions are determined by the vertex order and edge structure.

  3. _Crossing gadgets:_ When two copy lines cross (corresponding to an edge $(v_i, v_j) in E$), insert a crossing gadget that enforces: at most one of the two lines can be "active" (all vertices selected).

  4. _MIS correspondence:_ Each copy line has MIS contribution $approx |"line"|/2$. The gadgets add overhead $Delta$ such that:
  $ "MIS"(G_"grid") = "MIS"(G) + Delta $

  _Solution extraction._ For each copy line, check if the majority of its vertices are in the grid MIS. Map back: $v_i in S$ iff copy line $i$ is active.

  _Correctness._ ($arrow.r.double$) An IS in $G$ maps to selecting all copy line vertices for included vertices; crossing gadgets ensure no conflicts. ($arrow.l.double$) A grid MIS maps back to an IS by the copy line activity rule.
]

*Example: Petersen Graph.*#footnote[Generated using `cargo run --example export_petersen_mapping` from the accompanying code repository.] The Petersen graph ($n=10$, MIS$=4$) maps to a $30 times 42$ King's subgraph with 219 nodes and overhead $Delta = 89$. Solving MIS on the grid yields $"MIS"(G_"grid") = 4 + 89 = 93$. The weighted and unweighted KSG mappings share identical grid topology (same node positions and edges); only the vertex weights differ. With triangular lattice encoding @nguyen2023, the same graph maps to a $42 times 60$ grid with 395 nodes and overhead $Delta = 375$, giving $"MIS"(G_"tri") = 4 + 375 = 379$.

// Load JSON data
#let petersen = json("static/petersen_source.json")
#let square_weighted = json("static/petersen_square_weighted.json")
#let square_unweighted = json("static/petersen_square_unweighted.json")
#let triangular_mapping = json("static/petersen_triangular.json")

#figure(
  grid(
    columns: 3,
    gutter: 1.5em,
    align(center + horizon)[
      #{
        let pg = petersen-graph()
        canvas(length: 1cm, {
          for (u, v) in pg.edges { g-edge(pg.vertices.at(u), pg.vertices.at(v)) }
          for (k, pos) in pg.vertices.enumerate() {
            g-node(pos, fill: blue, stroke: none)
          }
        })
      }
      (a) Petersen graph
    ],
    align(center + horizon)[
      #draw-grid-graph(square_weighted)
      (b) King's subgraph (weighted)
    ],
    align(center + horizon)[
      #draw-triangular-graph(triangular_mapping)
      (c) Triangular lattice (weighted)
    ],
  ),
  caption: [Unit disk mappings of the Petersen graph. Blue: weight 1, red: weight 2, green: weight 3.],
) <fig:petersen-mapping>

#reduction-rule("MaximumIndependentSet", "TriangularSubgraph")[
  @nguyen2023 Any MIS problem on a general graph $G$ can be reduced to MIS on a weighted triangular lattice graph with at most quadratic overhead in the number of vertices.
][
  _Construction._ Same copy-line method as the KSG mapping, but uses a triangular lattice instead of a square grid. Crossing and simplifier gadgets are adapted for triangular geometry, producing a unit disk graph on a triangular grid where edges connect nodes within unit distance under the triangular metric.

  _Overhead._ Both vertex and edge counts grow as $O(n^2)$ where $n = |V|$, matching the KSG mapping.
]

*Weighted Extension.* For MWIS, copy lines use weighted vertices (weights 1, 2, or 3). Source weights $< 1$ are added to designated "pin" vertices.

*QUBO Mapping.* A QUBO problem $min bold(x)^top Q bold(x)$ maps to weighted MIS on a grid by:
1. Creating copy lines for each variable
2. Using XOR gadgets for couplings: $x_"out" = not(x_1 xor x_2)$
3. Adding weights for linear and quadratic terms

See #link("https://github.com/CodingThrust/problem-reductions/blob/main/examples/export_petersen_mapping.rs")[`export_petersen_mapping.rs`].

// Completeness check: warn about reduction rules in JSON but missing from paper
#context {
  let covered = covered-rules.get()
  let json-edges = {
    let edges = graph-data.edges.map(e => (graph-data.nodes.at(e.source).name, graph-data.nodes.at(e.target).name))
    let unique = ()
    for e in edges {
      if unique.find(u => u.at(0) == e.at(0) and u.at(1) == e.at(1)) == none {
        unique.push(e)
      }
    }
    unique
  }
  let missing = json-edges.filter(e => {
    covered.find(c => c.at(0) == e.at(0) and c.at(1) == e.at(1)) == none
  })
  if missing.len() > 0 {
    block(width: 100%, inset: (x: 1em, y: 0.5em), fill: rgb("#fff3cd"), stroke: (left: 3pt + rgb("#ffc107")))[
      #text(fill: rgb("#856404"), weight: "bold")[Warning: Missing reduction rules:] \
      #for m in missing [
        #text(fill: rgb("#856404"))[- #m.at(0) #sym.arrow.r #m.at(1)] \
      ]
    ]
  }
}

== Resource Estimation from Examples

The following table shows concrete variable overhead for example instances, generated from the reduction examples (`make examples`).

#let example-files = (
  "maximumindependentset_to_minimumvertexcover", "minimumvertexcover_to_maximumindependentset",
  "maximumindependentset_to_maximumsetpacking", "maximummatching_to_maximumsetpacking",
  "minimumvertexcover_to_minimumsetcovering",
  "maxcut_to_spinglass", "spinglass_to_maxcut",
  "spinglass_to_qubo", "qubo_to_spinglass",
  "maximumindependentset_to_qubo", "minimumvertexcover_to_qubo", "kcoloring_to_qubo",
  "maximumsetpacking_to_qubo", "ksatisfiability_to_qubo", "ilp_to_qubo",
  "satisfiability_to_maximumindependentset", "satisfiability_to_kcoloring", "satisfiability_to_minimumdominatingset", "satisfiability_to_ksatisfiability",
  "circuitsat_to_spinglass", "factoring_to_circuitsat",
  "maximumindependentset_to_ilp", "minimumvertexcover_to_ilp", "maximummatching_to_ilp",
  "kcoloring_to_ilp", "factoring_to_ilp",
  "maximumsetpacking_to_ilp", "minimumsetcovering_to_ilp",
  "minimumdominatingset_to_ilp", "maximumclique_to_ilp",
  "travelingsalesman_to_ilp",
)

#let examples = example-files.map(n => {
  let d = load-example(n)
  (name: n, data: d)
})

#pagebreak()
#bibliography("references.bib", style: "ieee")

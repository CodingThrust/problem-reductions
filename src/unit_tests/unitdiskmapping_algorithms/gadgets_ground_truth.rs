//! Tests that verify Rust gadget implementations match Julia ground truth.
//!
//! The ground truth is generated by scripts/dump_gadgets.jl and stored in
//! tests/data/gadgets_ground_truth.json

use crate::rules::unitdiskmapping::ksg::{
    KsgBranch, KsgBranchFix, KsgBranchFixB, KsgCross, KsgDanglingLeg, KsgEndTurn,
    KsgReflectedGadget, KsgRotatedGadget, KsgTCon, KsgTrivialTurn, KsgTurn, KsgWTurn, Mirror,
};
use crate::rules::unitdiskmapping::triangular::{
    WeightedTriBranch, WeightedTriBranchFix, WeightedTriBranchFixB, WeightedTriCross,
    WeightedTriEndTurn, WeightedTriTConDown, WeightedTriTConLeft, WeightedTriTConUp,
    WeightedTriTrivialTurnLeft, WeightedTriTrivialTurnRight, WeightedTriTurn, WeightedTriWTurn,
    WeightedTriangularGadget,
};
use crate::rules::unitdiskmapping::Pattern;
use serde::Deserialize;
use std::collections::HashMap;
use std::fs;

#[derive(Debug, Deserialize)]
#[allow(dead_code)]
struct GadgetData {
    name: String,
    size: Vec<usize>,
    cross_location: Vec<usize>,
    mis_overhead: i32,
    source_nodes: usize,
    mapped_nodes: usize,
    source_locs: Vec<Vec<usize>>,
    mapped_locs: Vec<Vec<usize>>,
    #[serde(default)]
    source_weights: Vec<i32>,
    #[serde(default)]
    mapped_weights: Vec<i32>,
    #[serde(default)]
    source_centers: Vec<Vec<usize>>,
    #[serde(default)]
    mapped_centers: Vec<Vec<usize>>,
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)]
struct GroundTruth {
    unweighted_square: Vec<GadgetData>,
    triangular: Vec<GadgetData>,
    weighted_square: Vec<GadgetData>,
    weighted_triangular: Vec<GadgetData>,
    rotated: Vec<GadgetData>,
    reflected: Vec<GadgetData>,
}

fn load_ground_truth() -> GroundTruth {
    let path = concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/tests/data/gadgets_ground_truth.json"
    );
    let content = fs::read_to_string(path).expect("Failed to read ground truth file");
    serde_json::from_str(&content).expect("Failed to parse ground truth JSON")
}

fn to_map(gadgets: &[GadgetData]) -> HashMap<String, &GadgetData> {
    gadgets.iter().map(|g| (g.name.clone(), g)).collect()
}

macro_rules! check_gadget {
    ($name:expr, $gadget:expr, $expected:expr) => {{
        let g = $gadget;
        let e = $expected;

        // Check size
        assert_eq!(g.size(), (e.size[0], e.size[1]), "{}: size mismatch", $name);

        // Check cross_location
        assert_eq!(
            g.cross_location(),
            (e.cross_location[0], e.cross_location[1]),
            "{}: cross_location mismatch",
            $name
        );

        // Check mis_overhead
        assert_eq!(
            g.mis_overhead(),
            e.mis_overhead,
            "{}: mis_overhead mismatch",
            $name
        );

        // Check source graph node count
        let (slocs, _, _) = g.source_graph();
        assert_eq!(
            slocs.len(),
            e.source_nodes,
            "{}: source_nodes count mismatch",
            $name
        );

        // Check mapped graph node count
        let (mlocs, _) = g.mapped_graph();
        assert_eq!(
            mlocs.len(),
            e.mapped_nodes,
            "{}: mapped_nodes count mismatch",
            $name
        );

        // Check source locations match (as sets, order may differ)
        let rust_slocs: std::collections::HashSet<_> = slocs.iter().cloned().collect();
        let julia_slocs: std::collections::HashSet<_> =
            e.source_locs.iter().map(|v| (v[0], v[1])).collect();
        assert_eq!(
            rust_slocs, julia_slocs,
            "{}: source_locs mismatch\nRust: {:?}\nJulia: {:?}",
            $name, rust_slocs, julia_slocs
        );

        // Check mapped locations match (as sets, order may differ)
        let rust_mlocs: std::collections::HashSet<_> = mlocs.iter().cloned().collect();
        let julia_mlocs: std::collections::HashSet<_> =
            e.mapped_locs.iter().map(|v| (v[0], v[1])).collect();
        assert_eq!(
            rust_mlocs, julia_mlocs,
            "{}: mapped_locs mismatch\nRust: {:?}\nJulia: {:?}",
            $name, rust_mlocs, julia_mlocs
        );
    }};
}

macro_rules! check_weighted_gadget {
    ($name:expr, $gadget:expr, $expected:expr) => {{
        let g = $gadget;
        let e = $expected;

        // Check size
        assert_eq!(g.size(), (e.size[0], e.size[1]), "{}: size mismatch", $name);

        // Check cross_location
        assert_eq!(
            g.cross_location(),
            (e.cross_location[0], e.cross_location[1]),
            "{}: cross_location mismatch",
            $name
        );

        // Note: We skip mis_overhead check for weighted gadgets because
        // Julia's WeightedGadget has different mis_overhead than the base gadget,
        // but Rust doesn't have a separate WeightedGadget type.

        // Check source graph node count
        let (slocs, _, _) = g.source_graph();
        assert_eq!(
            slocs.len(),
            e.source_nodes,
            "{}: source_nodes count mismatch",
            $name
        );

        // Check mapped graph node count
        let (mlocs, _) = g.mapped_graph();
        assert_eq!(
            mlocs.len(),
            e.mapped_nodes,
            "{}: mapped_nodes count mismatch",
            $name
        );

        // Check source locations match (as sets, order may differ)
        let rust_slocs: std::collections::HashSet<_> = slocs.iter().cloned().collect();
        let julia_slocs: std::collections::HashSet<_> =
            e.source_locs.iter().map(|v| (v[0], v[1])).collect();
        assert_eq!(
            rust_slocs, julia_slocs,
            "{}: source_locs mismatch\nRust: {:?}\nJulia: {:?}",
            $name, rust_slocs, julia_slocs
        );

        // Check mapped locations match (as sets, order may differ)
        let rust_mlocs: std::collections::HashSet<_> = mlocs.iter().cloned().collect();
        let julia_mlocs: std::collections::HashSet<_> =
            e.mapped_locs.iter().map(|v| (v[0], v[1])).collect();
        assert_eq!(
            rust_mlocs, julia_mlocs,
            "{}: mapped_locs mismatch\nRust: {:?}\nJulia: {:?}",
            $name, rust_mlocs, julia_mlocs
        );

        // Check source weights
        let sw = g.source_weights();
        assert_eq!(
            sw, e.source_weights,
            "{}: source_weights mismatch\nRust: {:?}\nJulia: {:?}",
            $name, sw, e.source_weights
        );

        // Check mapped weights
        let mw = g.mapped_weights();
        assert_eq!(
            mw, e.mapped_weights,
            "{}: mapped_weights mismatch\nRust: {:?}\nJulia: {:?}",
            $name, mw, e.mapped_weights
        );
    }};
}

// === Unweighted Square Gadget Tests ===

#[test]
fn test_unweighted_square_cross_false() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("Cross_false", KsgCross::<false>, map["Cross_false"]);
}

#[test]
fn test_unweighted_square_cross_true() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("Cross_true", KsgCross::<true>, map["Cross_true"]);
}

#[test]
fn test_unweighted_square_turn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("Turn", KsgTurn, map["Turn"]);
}

#[test]
fn test_unweighted_square_wturn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("WTurn", KsgWTurn, map["WTurn"]);
}

#[test]
fn test_unweighted_square_branch() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("Branch", KsgBranch, map["Branch"]);
}

#[test]
fn test_unweighted_square_branchfix() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("BranchFix", KsgBranchFix, map["BranchFix"]);
}

#[test]
fn test_unweighted_square_branchfixb() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("BranchFixB", KsgBranchFixB, map["BranchFixB"]);
}

#[test]
fn test_unweighted_square_tcon() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("TCon", KsgTCon, map["TCon"]);
}

#[test]
fn test_unweighted_square_trivialturn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("TrivialTurn", KsgTrivialTurn, map["TrivialTurn"]);
}

#[test]
fn test_unweighted_square_endturn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("EndTurn", KsgEndTurn, map["EndTurn"]);
}

#[test]
fn test_unweighted_square_danglingleg() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("DanglingLeg", KsgDanglingLeg, map["DanglingLeg"]);
}

// === Triangular Gadget Tests ===

#[test]
fn test_triangular_cross_false() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriCross_false", WeightedTriCross::<false>, map["TriCross_false"]);
}

#[test]
fn test_triangular_cross_true() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriCross_true", WeightedTriCross::<true>, map["TriCross_true"]);
}

#[test]
fn test_triangular_tcon_left() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriTCon_left", WeightedTriTConLeft, map["TriTCon_left"]);
}

#[test]
fn test_triangular_tcon_up() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriTCon_up", WeightedTriTConUp, map["TriTCon_up"]);
}

#[test]
fn test_triangular_tcon_down() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriTCon_down", WeightedTriTConDown, map["TriTCon_down"]);
}

#[test]
fn test_triangular_trivialturn_left() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!(
        "TriTrivialTurn_left",
        WeightedTriTrivialTurnLeft,
        map["TriTrivialTurn_left"]
    );
}

#[test]
fn test_triangular_trivialturn_right() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!(
        "TriTrivialTurn_right",
        WeightedTriTrivialTurnRight,
        map["TriTrivialTurn_right"]
    );
}

#[test]
fn test_triangular_endturn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriEndTurn", WeightedTriEndTurn, map["TriEndTurn"]);
}

#[test]
fn test_triangular_turn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriTurn", WeightedTriTurn, map["TriTurn"]);
}

#[test]
fn test_triangular_wturn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriWTurn", WeightedTriWTurn, map["TriWTurn"]);
}

#[test]
fn test_triangular_branchfix() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriBranchFix", WeightedTriBranchFix, map["TriBranchFix"]);
}

#[test]
fn test_triangular_branchfixb() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriBranchFixB", WeightedTriBranchFixB, map["TriBranchFixB"]);
}

#[test]
fn test_triangular_branch() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriBranch", WeightedTriBranch, map["TriBranch"]);
}

// === Weighted Square Gadget Tests ===

#[test]
fn test_weighted_square_cross_false() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("Cross_false", KsgCross::<false>, map["Cross_false"]);
}

#[test]
fn test_weighted_square_cross_true() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("Cross_true", KsgCross::<true>, map["Cross_true"]);
}

#[test]
fn test_weighted_square_turn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("Turn", KsgTurn, map["Turn"]);
}

#[test]
fn test_weighted_square_wturn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("WTurn", KsgWTurn, map["WTurn"]);
}

#[test]
fn test_weighted_square_branch() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("Branch", KsgBranch, map["Branch"]);
}

#[test]
fn test_weighted_square_branchfix() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("BranchFix", KsgBranchFix, map["BranchFix"]);
}

#[test]
fn test_weighted_square_branchfixb() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("BranchFixB", KsgBranchFixB, map["BranchFixB"]);
}

#[test]
fn test_weighted_square_tcon() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("TCon", KsgTCon, map["TCon"]);
}

#[test]
fn test_weighted_square_trivialturn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("TrivialTurn", KsgTrivialTurn, map["TrivialTurn"]);
}

#[test]
fn test_weighted_square_endturn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("EndTurn", KsgEndTurn, map["EndTurn"]);
}

#[test]
fn test_weighted_square_danglingleg() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("DanglingLeg", KsgDanglingLeg, map["DanglingLeg"]);
}

// === Rotated Gadget Tests ===

macro_rules! test_rotated {
    ($test_name:ident, $base:expr, $n:expr, $key:expr) => {
        #[test]
        fn $test_name() {
            let gt = load_ground_truth();
            let map = to_map(&gt.rotated);
            let gadget = KsgRotatedGadget::new($base, $n);
            check_gadget!($key, gadget, map[$key]);
        }
    };
}

macro_rules! test_reflected {
    ($test_name:ident, $base:expr, $mirror:expr, $key:expr) => {
        #[test]
        fn $test_name() {
            let gt = load_ground_truth();
            let map = to_map(&gt.reflected);
            let gadget = KsgReflectedGadget::new($base, $mirror);
            check_gadget!($key, gadget, map[$key]);
        }
    };
}

// Cross<false> rotations
test_rotated!(
    test_rotated_cross_false_rot1,
    KsgCross::<false>,
    1,
    "Cross_false_rot1"
);
test_rotated!(
    test_rotated_cross_false_rot2,
    KsgCross::<false>,
    2,
    "Cross_false_rot2"
);
test_rotated!(
    test_rotated_cross_false_rot3,
    KsgCross::<false>,
    3,
    "Cross_false_rot3"
);

// Cross<true> rotations
test_rotated!(
    test_rotated_cross_true_rot1,
    KsgCross::<true>,
    1,
    "Cross_true_rot1"
);
test_rotated!(
    test_rotated_cross_true_rot2,
    KsgCross::<true>,
    2,
    "Cross_true_rot2"
);
test_rotated!(
    test_rotated_cross_true_rot3,
    KsgCross::<true>,
    3,
    "Cross_true_rot3"
);

// Turn rotations
test_rotated!(test_rotated_turn_rot1, KsgTurn, 1, "Turn_rot1");
test_rotated!(test_rotated_turn_rot2, KsgTurn, 2, "Turn_rot2");
test_rotated!(test_rotated_turn_rot3, KsgTurn, 3, "Turn_rot3");

// WTurn rotations
test_rotated!(test_rotated_wturn_rot1, KsgWTurn, 1, "WTurn_rot1");
test_rotated!(test_rotated_wturn_rot2, KsgWTurn, 2, "WTurn_rot2");
test_rotated!(test_rotated_wturn_rot3, KsgWTurn, 3, "WTurn_rot3");

// Branch rotations
test_rotated!(test_rotated_branch_rot1, KsgBranch, 1, "Branch_rot1");
test_rotated!(test_rotated_branch_rot2, KsgBranch, 2, "Branch_rot2");
test_rotated!(test_rotated_branch_rot3, KsgBranch, 3, "Branch_rot3");

// BranchFix rotations
test_rotated!(test_rotated_branchfix_rot1, KsgBranchFix, 1, "BranchFix_rot1");
test_rotated!(test_rotated_branchfix_rot2, KsgBranchFix, 2, "BranchFix_rot2");
test_rotated!(test_rotated_branchfix_rot3, KsgBranchFix, 3, "BranchFix_rot3");

// BranchFixB rotations
test_rotated!(
    test_rotated_branchfixb_rot1,
    KsgBranchFixB,
    1,
    "BranchFixB_rot1"
);
test_rotated!(
    test_rotated_branchfixb_rot2,
    KsgBranchFixB,
    2,
    "BranchFixB_rot2"
);
test_rotated!(
    test_rotated_branchfixb_rot3,
    KsgBranchFixB,
    3,
    "BranchFixB_rot3"
);

// TCon rotations
test_rotated!(test_rotated_tcon_rot1, KsgTCon, 1, "TCon_rot1");
test_rotated!(test_rotated_tcon_rot2, KsgTCon, 2, "TCon_rot2");
test_rotated!(test_rotated_tcon_rot3, KsgTCon, 3, "TCon_rot3");

// TrivialTurn rotations
test_rotated!(
    test_rotated_trivialturn_rot1,
    KsgTrivialTurn,
    1,
    "TrivialTurn_rot1"
);
test_rotated!(
    test_rotated_trivialturn_rot2,
    KsgTrivialTurn,
    2,
    "TrivialTurn_rot2"
);
test_rotated!(
    test_rotated_trivialturn_rot3,
    KsgTrivialTurn,
    3,
    "TrivialTurn_rot3"
);

// EndTurn rotations
test_rotated!(test_rotated_endturn_rot1, KsgEndTurn, 1, "EndTurn_rot1");
test_rotated!(test_rotated_endturn_rot2, KsgEndTurn, 2, "EndTurn_rot2");
test_rotated!(test_rotated_endturn_rot3, KsgEndTurn, 3, "EndTurn_rot3");

// DanglingLeg rotations
test_rotated!(
    test_rotated_danglingleg_rot1,
    KsgDanglingLeg,
    1,
    "DanglingLeg_rot1"
);
test_rotated!(
    test_rotated_danglingleg_rot2,
    KsgDanglingLeg,
    2,
    "DanglingLeg_rot2"
);
test_rotated!(
    test_rotated_danglingleg_rot3,
    KsgDanglingLeg,
    3,
    "DanglingLeg_rot3"
);

// === Reflected Gadget Tests ===

// Cross<false> reflections
test_reflected!(
    test_reflected_cross_false_x,
    KsgCross::<false>,
    Mirror::X,
    "Cross_false_ref_x"
);
test_reflected!(
    test_reflected_cross_false_y,
    KsgCross::<false>,
    Mirror::Y,
    "Cross_false_ref_y"
);
test_reflected!(
    test_reflected_cross_false_diag,
    KsgCross::<false>,
    Mirror::Diag,
    "Cross_false_ref_diag"
);
test_reflected!(
    test_reflected_cross_false_offdiag,
    KsgCross::<false>,
    Mirror::OffDiag,
    "Cross_false_ref_offdiag"
);

// Cross<true> reflections
test_reflected!(
    test_reflected_cross_true_x,
    KsgCross::<true>,
    Mirror::X,
    "Cross_true_ref_x"
);
test_reflected!(
    test_reflected_cross_true_y,
    KsgCross::<true>,
    Mirror::Y,
    "Cross_true_ref_y"
);
test_reflected!(
    test_reflected_cross_true_diag,
    KsgCross::<true>,
    Mirror::Diag,
    "Cross_true_ref_diag"
);
test_reflected!(
    test_reflected_cross_true_offdiag,
    KsgCross::<true>,
    Mirror::OffDiag,
    "Cross_true_ref_offdiag"
);

// Turn reflections
test_reflected!(test_reflected_turn_x, KsgTurn, Mirror::X, "Turn_ref_x");
test_reflected!(test_reflected_turn_y, KsgTurn, Mirror::Y, "Turn_ref_y");
test_reflected!(
    test_reflected_turn_diag,
    KsgTurn,
    Mirror::Diag,
    "Turn_ref_diag"
);
test_reflected!(
    test_reflected_turn_offdiag,
    KsgTurn,
    Mirror::OffDiag,
    "Turn_ref_offdiag"
);

// WTurn reflections
test_reflected!(test_reflected_wturn_x, KsgWTurn, Mirror::X, "WTurn_ref_x");
test_reflected!(test_reflected_wturn_y, KsgWTurn, Mirror::Y, "WTurn_ref_y");
test_reflected!(
    test_reflected_wturn_diag,
    KsgWTurn,
    Mirror::Diag,
    "WTurn_ref_diag"
);
test_reflected!(
    test_reflected_wturn_offdiag,
    KsgWTurn,
    Mirror::OffDiag,
    "WTurn_ref_offdiag"
);

// Branch reflections
test_reflected!(test_reflected_branch_x, KsgBranch, Mirror::X, "Branch_ref_x");
test_reflected!(test_reflected_branch_y, KsgBranch, Mirror::Y, "Branch_ref_y");
test_reflected!(
    test_reflected_branch_diag,
    KsgBranch,
    Mirror::Diag,
    "Branch_ref_diag"
);
test_reflected!(
    test_reflected_branch_offdiag,
    KsgBranch,
    Mirror::OffDiag,
    "Branch_ref_offdiag"
);

// BranchFix reflections
test_reflected!(
    test_reflected_branchfix_x,
    KsgBranchFix,
    Mirror::X,
    "BranchFix_ref_x"
);
test_reflected!(
    test_reflected_branchfix_y,
    KsgBranchFix,
    Mirror::Y,
    "BranchFix_ref_y"
);
test_reflected!(
    test_reflected_branchfix_diag,
    KsgBranchFix,
    Mirror::Diag,
    "BranchFix_ref_diag"
);
test_reflected!(
    test_reflected_branchfix_offdiag,
    KsgBranchFix,
    Mirror::OffDiag,
    "BranchFix_ref_offdiag"
);

// BranchFixB reflections
test_reflected!(
    test_reflected_branchfixb_x,
    KsgBranchFixB,
    Mirror::X,
    "BranchFixB_ref_x"
);
test_reflected!(
    test_reflected_branchfixb_y,
    KsgBranchFixB,
    Mirror::Y,
    "BranchFixB_ref_y"
);
test_reflected!(
    test_reflected_branchfixb_diag,
    KsgBranchFixB,
    Mirror::Diag,
    "BranchFixB_ref_diag"
);
test_reflected!(
    test_reflected_branchfixb_offdiag,
    KsgBranchFixB,
    Mirror::OffDiag,
    "BranchFixB_ref_offdiag"
);

// TCon reflections
test_reflected!(test_reflected_tcon_x, KsgTCon, Mirror::X, "TCon_ref_x");
test_reflected!(test_reflected_tcon_y, KsgTCon, Mirror::Y, "TCon_ref_y");
test_reflected!(
    test_reflected_tcon_diag,
    KsgTCon,
    Mirror::Diag,
    "TCon_ref_diag"
);
test_reflected!(
    test_reflected_tcon_offdiag,
    KsgTCon,
    Mirror::OffDiag,
    "TCon_ref_offdiag"
);

// TrivialTurn reflections
test_reflected!(
    test_reflected_trivialturn_x,
    KsgTrivialTurn,
    Mirror::X,
    "TrivialTurn_ref_x"
);
test_reflected!(
    test_reflected_trivialturn_y,
    KsgTrivialTurn,
    Mirror::Y,
    "TrivialTurn_ref_y"
);
test_reflected!(
    test_reflected_trivialturn_diag,
    KsgTrivialTurn,
    Mirror::Diag,
    "TrivialTurn_ref_diag"
);
test_reflected!(
    test_reflected_trivialturn_offdiag,
    KsgTrivialTurn,
    Mirror::OffDiag,
    "TrivialTurn_ref_offdiag"
);

// EndTurn reflections
test_reflected!(
    test_reflected_endturn_x,
    KsgEndTurn,
    Mirror::X,
    "EndTurn_ref_x"
);
test_reflected!(
    test_reflected_endturn_y,
    KsgEndTurn,
    Mirror::Y,
    "EndTurn_ref_y"
);
test_reflected!(
    test_reflected_endturn_diag,
    KsgEndTurn,
    Mirror::Diag,
    "EndTurn_ref_diag"
);
test_reflected!(
    test_reflected_endturn_offdiag,
    KsgEndTurn,
    Mirror::OffDiag,
    "EndTurn_ref_offdiag"
);

// DanglingLeg reflections
test_reflected!(
    test_reflected_danglingleg_x,
    KsgDanglingLeg,
    Mirror::X,
    "DanglingLeg_ref_x"
);
test_reflected!(
    test_reflected_danglingleg_y,
    KsgDanglingLeg,
    Mirror::Y,
    "DanglingLeg_ref_y"
);
test_reflected!(
    test_reflected_danglingleg_diag,
    KsgDanglingLeg,
    Mirror::Diag,
    "DanglingLeg_ref_diag"
);
test_reflected!(
    test_reflected_danglingleg_offdiag,
    KsgDanglingLeg,
    Mirror::OffDiag,
    "DanglingLeg_ref_offdiag"
);

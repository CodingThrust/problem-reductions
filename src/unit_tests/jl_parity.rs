//! Julia ProblemReductions.jl parity tests.
//!
//! These tests load JSON fixtures generated by `scripts/jl/generate_testdata.jl`
//! and compare evaluations, solver results, and reduction outputs against the
//! Julia reference implementation.

use crate::models::specialized::{Assignment, BooleanExpr, Circuit};
use crate::prelude::*;
use crate::solvers::ILPSolver;
use crate::topology::SimpleGraph;
use std::collections::HashSet;

// ── JSON helpers ────────────────────────────────────────────────────

fn parse_edges(instance: &serde_json::Value) -> Vec<(usize, usize)> {
    instance["edges"]
        .as_array()
        .expect("edges should be an array")
        .iter()
        .map(|e| {
            let arr = e.as_array().expect("edge should be a [u, v] array");
            (
                arr[0].as_u64().expect("edge vertex should be u64") as usize,
                arr[1].as_u64().expect("edge vertex should be u64") as usize,
            )
        })
        .collect()
}

fn parse_weighted_edges(instance: &serde_json::Value) -> Vec<(usize, usize, i32)> {
    let edges = parse_edges(instance);
    let weights: Vec<i32> = instance["weights"]
        .as_array()
        .expect("weights should be an array")
        .iter()
        .map(|w| w.as_i64().expect("weight should be i64") as i32)
        .collect();
    edges
        .into_iter()
        .zip(weights)
        .map(|((u, v), w)| (u, v, w))
        .collect()
}

fn parse_config(val: &serde_json::Value) -> Vec<usize> {
    val.as_array()
        .expect("config should be an array")
        .iter()
        .map(|v| v.as_u64().expect("config element should be u64") as usize)
        .collect()
}

fn parse_configs_set(val: &serde_json::Value) -> HashSet<Vec<usize>> {
    val.as_array()
        .expect("configs set should be an array")
        .iter()
        .map(parse_config)
        .collect()
}

fn parse_i32_vec(val: &serde_json::Value) -> Vec<i32> {
    val.as_array()
        .expect("should be an array of integers")
        .iter()
        .map(|v| v.as_i64().expect("element should be i64") as i32)
        .collect()
}

fn parse_sets(val: &serde_json::Value) -> Vec<Vec<usize>> {
    val.as_array()
        .expect("sets should be an array")
        .iter()
        .map(|s| {
            s.as_array()
                .expect("set should be an array")
                .iter()
                .map(|v| v.as_u64().expect("set element should be u64") as usize)
                .collect()
        })
        .collect()
}

fn parse_sat_clauses(instance: &serde_json::Value) -> (usize, Vec<CNFClause>) {
    let num_vars = instance["num_variables"].as_u64().unwrap() as usize;
    let clauses: Vec<CNFClause> = instance["clauses"]
        .as_array()
        .unwrap()
        .iter()
        .map(|clause| {
            let literals: Vec<i32> = clause["literals"]
                .as_array()
                .unwrap()
                .iter()
                .map(|lit| {
                    let var = lit["variable"].as_u64().unwrap() as i32 + 1; // Convert to 1-indexed
                    let negated = lit["negated"].as_bool().unwrap();
                    if negated { -var } else { var }
                })
                .collect();
            CNFClause::new(literals)
        })
        .collect();
    (num_vars, clauses)
}

/// Flip a binary config: 0<->1. Used for SpinGlass spin convention mapping.
/// Julia: config 0 -> spin +1 (up), config 1 -> spin -1 (down).
/// Rust:  config 0 -> spin -1 (down), config 1 -> spin +1 (up).
fn flip_config(config: &[usize]) -> Vec<usize> {
    config.iter().map(|&x| 1 - x).collect()
}

fn flip_configs_set(configs: &HashSet<Vec<usize>>) -> HashSet<Vec<usize>> {
    configs.iter().map(|c| flip_config(c)).collect()
}

fn find_instance_by_label<'a>(data: &'a serde_json::Value, label: &str) -> &'a serde_json::Value {
    data["instances"]
        .as_array()
        .unwrap()
        .iter()
        .find(|inst| inst["label"].as_str().unwrap() == label)
        .unwrap_or_else(|| panic!("Instance '{label}' not found"))
}

// ── Model evaluation tests ──────────────────────────────────────────

#[test]
fn test_jl_parity_independentset_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/independentset.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let nv = instance["instance"]["num_vertices"].as_u64().unwrap() as usize;
        let edges = parse_edges(&instance["instance"]);
        let weights = parse_i32_vec(&instance["instance"]["weights"]);

        let problem = if weights.iter().all(|&w| w == 1) {
            MaximumIndependentSet::<SimpleGraph, i32>::new(nv, edges)
        } else {
            MaximumIndependentSet::with_weights(nv, edges, weights)
        };

        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let result = problem.evaluate(&config);
            let jl_valid = eval["is_valid"].as_bool().unwrap();
            assert_eq!(
                result.is_valid(),
                jl_valid,
                "IS validity mismatch for config {:?}",
                config
            );
            if jl_valid {
                let jl_size = eval["size"].as_i64().unwrap() as i32;
                assert_eq!(
                    result.unwrap(),
                    jl_size,
                    "IS size mismatch for config {:?}",
                    config
                );
            }
        }

        let best = BruteForce::new().find_all_best(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best: HashSet<Vec<usize>> = best.into_iter().collect();
        assert_eq!(rust_best, jl_best, "IS best solutions mismatch");
    }
}

#[test]
fn test_jl_parity_spinglass_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/spinglass.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let nv = instance["instance"]["num_vertices"].as_u64().unwrap() as usize;
        let edges = parse_edges(&instance["instance"]);
        let j_values = parse_i32_vec(&instance["instance"]["J"]);
        let h_values = parse_i32_vec(&instance["instance"]["h"]);

        let interactions: Vec<((usize, usize), i32)> =
            edges.into_iter().zip(j_values).collect();

        let problem = SpinGlass::<SimpleGraph, i32>::new(nv, interactions, h_values);

        for eval in instance["evaluations"].as_array().unwrap() {
            let jl_config = parse_config(&eval["config"]);
            // Flip config for spin convention: Julia 0->+1, Rust 0->-1
            let config = flip_config(&jl_config);
            let result = problem.evaluate(&config);
            let jl_size = eval["size"].as_i64().unwrap() as i32;
            assert!(
                result.is_valid(),
                "SpinGlass should always be valid, config {:?}",
                config
            );
            assert_eq!(
                result.unwrap(),
                jl_size,
                "SpinGlass energy mismatch for config {:?} (jl {:?}): rust={}, jl={}",
                config,
                jl_config,
                result.unwrap(),
                jl_size
            );
        }

        let best = BruteForce::new().find_all_best(&problem);
        let jl_best = flip_configs_set(&parse_configs_set(&instance["best_solutions"]));
        let rust_best: HashSet<Vec<usize>> = best.into_iter().collect();
        assert_eq!(rust_best, jl_best, "SpinGlass best solutions mismatch");
    }
}

#[test]
fn test_jl_parity_maxcut_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/maxcut.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let nv = instance["instance"]["num_vertices"].as_u64().unwrap() as usize;
        let weighted_edges = parse_weighted_edges(&instance["instance"]);

        let problem = MaxCut::<SimpleGraph, i32>::new(nv, weighted_edges);

        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let result = problem.evaluate(&config);
            let jl_size = eval["size"].as_i64().unwrap() as i32;
            assert!(result.is_valid(), "MaxCut should always be valid");
            assert_eq!(
                result.unwrap(),
                jl_size,
                "MaxCut size mismatch for config {:?}",
                config
            );
        }

        let best = BruteForce::new().find_all_best(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best: HashSet<Vec<usize>> = best.into_iter().collect();
        assert_eq!(rust_best, jl_best, "MaxCut best solutions mismatch");
    }
}

#[test]
fn test_jl_parity_qubo_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/qubo.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let jl_matrix: Vec<Vec<f64>> = instance["instance"]["matrix"]
            .as_array()
            .unwrap()
            .iter()
            .map(|row| {
                row.as_array()
                    .unwrap()
                    .iter()
                    .map(|v| v.as_f64().unwrap())
                    .collect()
            })
            .collect();

        // Julia QUBO uses full symmetric matrix: sum(Q_ij * x_i * x_j) for all (i,j)
        // Rust QUBO uses upper triangle only: sum(Q_ij * x_i * x_j) for j >= i
        // Convert: for i < j, Q_rust[i][j] = Q_jl[i][j] + Q_jl[j][i]
        let n = jl_matrix.len();
        let mut rust_matrix = vec![vec![0.0f64; n]; n];
        for i in 0..n {
            rust_matrix[i][i] = jl_matrix[i][i];
            for j in (i + 1)..n {
                rust_matrix[i][j] = jl_matrix[i][j] + jl_matrix[j][i];
            }
        }
        let problem = QUBO::from_matrix(rust_matrix);

        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let result: SolutionSize<f64> = Problem::evaluate(&problem, &config);
            let jl_size = eval["size"].as_f64().unwrap();
            assert!(result.is_valid(), "QUBO should always be valid");
            assert!(
                (result.unwrap() - jl_size).abs() < 1e-10,
                "QUBO value mismatch for config {:?}: jl={}",
                config,
                jl_size
            );
        }

        let best = BruteForce::new().find_all_best(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best: HashSet<Vec<usize>> = best.into_iter().collect();
        assert_eq!(rust_best, jl_best, "QUBO best solutions mismatch");
    }
}

#[test]
fn test_jl_parity_satisfiability_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/satisfiability.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let (num_vars, clauses) = parse_sat_clauses(&instance["instance"]);
        let problem = Satisfiability::new(num_vars, clauses);
        let num_clauses = instance["instance"]["clauses"].as_array().unwrap().len();

        // For SAT: Julia uses EXTREMA mode (counts satisfied clauses, always valid)
        // Rust uses bool (true iff ALL clauses satisfied)
        // Parity check: Rust true <-> Julia size == num_clauses
        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let rust_result = problem.evaluate(&config);
            let jl_size = eval["size"].as_u64().unwrap() as usize;
            let jl_all_satisfied = jl_size == num_clauses;
            assert_eq!(
                rust_result, jl_all_satisfied,
                "SAT eval mismatch for config {:?}: rust={}, jl_size={}/{}",
                config, rust_result, jl_size, num_clauses
            );
        }

        // best_solutions from Julia = configs maximizing satisfied clauses
        // For satisfiable formulas, these are exactly the satisfying assignments
        // For unsatisfiable formulas, Rust find_all_satisfying returns empty
        let rust_best = BruteForce::new().find_all_satisfying(&problem);
        let rust_best_set: HashSet<Vec<usize>> = rust_best.into_iter().collect();
        if !rust_best_set.is_empty() {
            let jl_best = parse_configs_set(&instance["best_solutions"]);
            assert_eq!(rust_best_set, jl_best, "SAT best solutions mismatch");
        }
    }
}

#[test]
fn test_jl_parity_ksatisfiability_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/ksatisfiability.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let (num_vars, clauses) = parse_sat_clauses(&instance["instance"]);
        let num_clauses = instance["instance"]["clauses"].as_array().unwrap().len();
        let problem = KSatisfiability::<3>::new(num_vars, clauses);

        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let rust_result = problem.evaluate(&config);
            let jl_size = eval["size"].as_u64().unwrap() as usize;
            let jl_all_satisfied = jl_size == num_clauses;
            assert_eq!(
                rust_result, jl_all_satisfied,
                "KSat eval mismatch for config {:?}",
                config
            );
        }

        let rust_best = BruteForce::new().find_all_satisfying(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best_set: HashSet<Vec<usize>> = rust_best.into_iter().collect();
        assert_eq!(rust_best_set, jl_best, "KSat best solutions mismatch");
    }
}

#[test]
fn test_jl_parity_vertexcovering_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/vertexcovering.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let nv = instance["instance"]["num_vertices"].as_u64().unwrap() as usize;
        let edges = parse_edges(&instance["instance"]);
        let weights = parse_i32_vec(&instance["instance"]["weights"]);

        let problem = if weights.iter().all(|&w| w == 1) {
            MinimumVertexCover::<SimpleGraph, i32>::new(nv, edges)
        } else {
            MinimumVertexCover::with_weights(nv, edges, weights)
        };

        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let result = problem.evaluate(&config);
            let jl_valid = eval["is_valid"].as_bool().unwrap();
            assert_eq!(
                result.is_valid(),
                jl_valid,
                "VC validity mismatch for config {:?}",
                config
            );
            if jl_valid {
                let jl_size = eval["size"].as_i64().unwrap() as i32;
                assert_eq!(
                    result.unwrap(),
                    jl_size,
                    "VC size mismatch for config {:?}",
                    config
                );
            }
        }

        let best = BruteForce::new().find_all_best(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best: HashSet<Vec<usize>> = best.into_iter().collect();
        assert_eq!(rust_best, jl_best, "VC best solutions mismatch");
    }
}

#[test]
fn test_jl_parity_setpacking_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/setpacking.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let sets = parse_sets(&instance["instance"]["sets"]);
        let weights = parse_i32_vec(&instance["instance"]["weights"]);

        let problem = if weights.iter().all(|&w| w == 1) {
            MaximumSetPacking::<i32>::new(sets)
        } else {
            MaximumSetPacking::with_weights(sets, weights)
        };

        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let result = problem.evaluate(&config);
            let jl_valid = eval["is_valid"].as_bool().unwrap();
            assert_eq!(
                result.is_valid(),
                jl_valid,
                "SetPacking validity mismatch for config {:?}",
                config
            );
            if jl_valid {
                let jl_size = eval["size"].as_i64().unwrap() as i32;
                assert_eq!(
                    result.unwrap(),
                    jl_size,
                    "SetPacking size mismatch for config {:?}",
                    config
                );
            }
        }

        let best = BruteForce::new().find_all_best(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best: HashSet<Vec<usize>> = best.into_iter().collect();
        assert_eq!(rust_best, jl_best, "SetPacking best solutions mismatch");
    }
}

#[test]
fn test_jl_parity_matching_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/matching.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let nv = instance["instance"]["num_vertices"].as_u64().unwrap() as usize;
        let weighted_edges = parse_weighted_edges(&instance["instance"]);

        let problem = MaximumMatching::<SimpleGraph, i32>::new(nv, weighted_edges);

        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let result = problem.evaluate(&config);
            let jl_valid = eval["is_valid"].as_bool().unwrap();
            assert_eq!(
                result.is_valid(),
                jl_valid,
                "Matching validity mismatch for config {:?}",
                config
            );
            if jl_valid {
                let jl_size = eval["size"].as_i64().unwrap() as i32;
                assert_eq!(
                    result.unwrap(),
                    jl_size,
                    "Matching size mismatch for config {:?}",
                    config
                );
            }
        }

        let best = BruteForce::new().find_all_best(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best: HashSet<Vec<usize>> = best.into_iter().collect();
        assert_eq!(rust_best, jl_best, "Matching best solutions mismatch");
    }
}

#[test]
fn test_jl_parity_factoring_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/factoring.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let m = instance["instance"]["m"].as_u64().unwrap() as usize;
        let n = instance["instance"]["n"].as_u64().unwrap() as usize;
        let input = instance["instance"]["input"].as_u64().unwrap();
        let problem = Factoring::new(m, n, input);

        // Julia Factoring: SolutionSize(0, true) if factors match, SolutionSize(0, false) otherwise
        // Rust Factoring: SolutionSize::Valid(|a*b - target|)
        // Parity: Julia is_valid=true <-> Rust value() == 0
        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let result = problem.evaluate(&config);
            let jl_valid = eval["is_valid"].as_bool().unwrap();
            if jl_valid {
                assert_eq!(
                    result.unwrap(),
                    0,
                    "Factoring: valid config {:?} should have distance 0",
                    config
                );
            } else {
                assert_ne!(
                    result.unwrap(),
                    0,
                    "Factoring: invalid config {:?} should have nonzero distance",
                    config
                );
            }
        }

        let best = BruteForce::new().find_all_best(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best: HashSet<Vec<usize>> = best.into_iter().collect();
        assert_eq!(rust_best, jl_best, "Factoring best solutions mismatch");
    }
}

#[test]
fn test_jl_parity_dominatingset_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/dominatingset.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let nv = instance["instance"]["num_vertices"].as_u64().unwrap() as usize;
        let edges = parse_edges(&instance["instance"]);

        let problem = MinimumDominatingSet::<SimpleGraph, i32>::new(nv, edges);

        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let result = problem.evaluate(&config);
            let jl_valid = eval["is_valid"].as_bool().unwrap();
            let jl_size = eval["size"].as_i64().unwrap() as i32;
            assert_eq!(
                result.is_valid(),
                jl_valid,
                "DominatingSet validity mismatch for config {:?}",
                config
            );
            if jl_valid {
                assert_eq!(
                    result.unwrap(),
                    jl_size,
                    "DominatingSet size mismatch for config {:?}",
                    config
                );
            }
        }

        let best = BruteForce::new().find_all_best(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best: HashSet<Vec<usize>> = best.into_iter().collect();
        assert_eq!(
            rust_best, jl_best,
            "DominatingSet best solutions mismatch"
        );
    }
}

#[test]
fn test_jl_parity_maximalis_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/maximalis.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let nv = instance["instance"]["num_vertices"].as_u64().unwrap() as usize;
        let edges = parse_edges(&instance["instance"]);

        let problem = MaximalIS::<SimpleGraph, i32>::new(nv, edges);

        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let result = problem.evaluate(&config);
            let jl_valid = eval["is_valid"].as_bool().unwrap();
            let jl_size = eval["size"].as_i64().unwrap() as i32;
            assert_eq!(
                result.is_valid(),
                jl_valid,
                "MaximalIS validity mismatch for config {:?}",
                config
            );
            if jl_valid {
                assert_eq!(
                    result.unwrap(),
                    jl_size,
                    "MaximalIS size mismatch for config {:?}",
                    config
                );
            }
        }

        let best = BruteForce::new().find_all_best(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best: HashSet<Vec<usize>> = best.into_iter().collect();
        assert_eq!(rust_best, jl_best, "MaximalIS best solutions mismatch");
    }
}

#[test]
fn test_jl_parity_paintshop_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/paintshop.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let sequence: Vec<String> = instance["instance"]["sequence"]
            .as_array()
            .unwrap()
            .iter()
            .map(|v| v.as_str().unwrap().to_string())
            .collect();

        let problem = PaintShop::new(sequence);

        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let result = problem.evaluate(&config);
            let jl_valid = eval["is_valid"].as_bool().unwrap();
            let jl_size = eval["size"].as_i64().unwrap() as i32;
            assert!(
                result.is_valid() == jl_valid,
                "PaintShop validity mismatch for config {:?}",
                config
            );
            if jl_valid {
                assert_eq!(
                    result.unwrap(),
                    jl_size,
                    "PaintShop switches mismatch for config {:?}",
                    config
                );
            }
        }

        let best = BruteForce::new().find_all_best(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best: HashSet<Vec<usize>> = best.into_iter().collect();
        assert_eq!(rust_best, jl_best, "PaintShop best solutions mismatch");
    }
}

#[test]
fn test_jl_parity_coloring_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/coloring.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let nv = instance["instance"]["num_vertices"].as_u64().unwrap() as usize;
        let edges = parse_edges(&instance["instance"]);

        let num_edges = edges.len();
        let problem = KColoring::<3, SimpleGraph>::new(nv, edges);

        // KColoring: Rust Metric=bool, Julia uses EXTREMA (counts valid edges).
        // Julia size = count of properly colored edges, is_valid always true.
        // Mapping: Rust true <-> Julia size == num_edges (all edges properly colored)
        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let result: bool = problem.evaluate(&config);
            let jl_size = eval["size"].as_i64().unwrap() as usize;
            let jl_proper = jl_size == num_edges;
            assert_eq!(
                result, jl_proper,
                "KColoring validity mismatch for config {:?}: rust={}, jl_size={}/{}",
                config, result, jl_size, num_edges,
            );
        }

        let all_sat = BruteForce::new().find_all_satisfying(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_sat: HashSet<Vec<usize>> = all_sat.into_iter().collect();
        assert_eq!(
            rust_sat, jl_best,
            "KColoring satisfying solutions mismatch"
        );
    }
}

#[test]
fn test_jl_parity_setcovering_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/setcovering.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let universe_size = instance["instance"]["universe_size"].as_u64().unwrap() as usize;
        let sets = parse_sets(&instance["instance"]["sets"]);
        let weights = parse_i32_vec(&instance["instance"]["weights"]);

        let problem = MinimumSetCovering::<i32>::with_weights(universe_size, sets, weights);

        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let result = problem.evaluate(&config);
            let jl_valid = eval["is_valid"].as_bool().unwrap();
            let jl_size = eval["size"].as_i64().unwrap() as i32;
            assert_eq!(
                result.is_valid(),
                jl_valid,
                "SetCovering validity mismatch for config {:?}",
                config
            );
            if jl_valid {
                assert_eq!(
                    result.unwrap(),
                    jl_size,
                    "SetCovering size mismatch for config {:?}",
                    config
                );
            }
        }

        let best = BruteForce::new().find_all_best(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best: HashSet<Vec<usize>> = best.into_iter().collect();
        assert_eq!(
            rust_best, jl_best,
            "SetCovering best solutions mismatch"
        );
    }
}

// ── Reduction parity tests ──────────────────────────────────────────

#[test]
fn test_jl_parity_independentset_to_setpacking() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/independentset_to_setpacking.json"))
            .unwrap();

    for case in data["cases"].as_array().unwrap() {
        let jl_best_source = parse_configs_set(&case["best_source"]);
        let jl_extracted_multiple = parse_configs_set(&case["extracted_multiple"]);

        let is_data: serde_json::Value =
            serde_json::from_str(include_str!("../../tests/data/jl/independentset.json")).unwrap();
        let inst = &is_data["instances"][0]["instance"];
        let nv = inst["num_vertices"].as_u64().unwrap() as usize;
        let edges = parse_edges(inst);
        let source = MaximumIndependentSet::<SimpleGraph, i32>::new(nv, edges);

        let result = ReduceTo::<MaximumSetPacking<i32>>::reduce_to(&source);
        let target = result.target_problem();

        let solver = BruteForce::new();
        let best_target = solver.find_all_best(target);
        let best_source = solver.find_all_best(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();

        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();

        assert!(
            extracted.is_subset(&best_source_set),
            "Extracted solutions should be among best source solutions"
        );

        assert_eq!(best_source_set, jl_best_source, "Best source mismatch");
        assert_eq!(
            jl_extracted_multiple, jl_best_source,
            "Julia extracted_multiple should match best_source"
        );
    }
}

#[test]
fn test_jl_parity_setpacking_to_independentset() {
    let data: serde_json::Value = serde_json::from_str(include_str!(
        "../../tests/data/jl/setpacking_to_independentset.json"
    ))
    .unwrap();

    for case in data["cases"].as_array().unwrap() {
        let jl_best_source = parse_configs_set(&case["best_source"]);

        let sp_data: serde_json::Value =
            serde_json::from_str(include_str!("../../tests/data/jl/setpacking.json")).unwrap();
        let inst = &sp_data["instances"][0]["instance"];
        let sets = parse_sets(&inst["sets"]);
        let source = MaximumSetPacking::<i32>::new(sets);

        let result = ReduceTo::<MaximumIndependentSet<SimpleGraph, i32>>::reduce_to(&source);
        let target = result.target_problem();

        let solver = BruteForce::new();
        let best_target = solver.find_all_best(target);
        let best_source = solver.find_all_best(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();

        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();

        assert!(extracted.is_subset(&best_source_set));
        assert_eq!(best_source_set, jl_best_source, "Best source mismatch");
    }
}

#[test]
fn test_jl_parity_independentset_to_vertexcovering() {
    let data: serde_json::Value = serde_json::from_str(include_str!(
        "../../tests/data/jl/independentset_to_vertexcovering.json"
    ))
    .unwrap();

    for case in data["cases"].as_array().unwrap() {
        let jl_best_source = parse_configs_set(&case["best_source"]);

        let is_data: serde_json::Value =
            serde_json::from_str(include_str!("../../tests/data/jl/independentset.json")).unwrap();
        let inst = &is_data["instances"][0]["instance"];
        let nv = inst["num_vertices"].as_u64().unwrap() as usize;
        let edges = parse_edges(inst);
        let source = MaximumIndependentSet::<SimpleGraph, i32>::new(nv, edges);

        let result = ReduceTo::<MinimumVertexCover<SimpleGraph, i32>>::reduce_to(&source);
        let target = result.target_problem();

        let solver = BruteForce::new();
        let best_target = solver.find_all_best(target);
        let best_source = solver.find_all_best(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();

        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();

        assert!(extracted.is_subset(&best_source_set));
        assert_eq!(best_source_set, jl_best_source, "Best source mismatch");
    }
}

#[test]
fn test_jl_parity_vertexcovering_to_setcovering() {
    let data: serde_json::Value = serde_json::from_str(include_str!(
        "../../tests/data/jl/vertexcovering_to_setcovering.json"
    ))
    .unwrap();

    for case in data["cases"].as_array().unwrap() {
        let jl_best_source = parse_configs_set(&case["best_source"]);

        let vc_data: serde_json::Value =
            serde_json::from_str(include_str!("../../tests/data/jl/vertexcovering.json")).unwrap();
        let inst = &vc_data["instances"][0]["instance"];
        let nv = inst["num_vertices"].as_u64().unwrap() as usize;
        let edges = parse_edges(inst);
        let weights = parse_i32_vec(&inst["weights"]);
        let source = MinimumVertexCover::with_weights(nv, edges, weights);

        let result = ReduceTo::<MinimumSetCovering<i32>>::reduce_to(&source);
        let target = result.target_problem();

        let solver = BruteForce::new();
        let best_target = solver.find_all_best(target);
        let best_source = solver.find_all_best(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();

        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();

        assert!(extracted.is_subset(&best_source_set));
        assert_eq!(best_source_set, jl_best_source, "Best source mismatch");
    }
}

#[test]
fn test_jl_parity_spinglass_to_maxcut() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/spinglass_to_maxcut.json")).unwrap();

    for case in data["cases"].as_array().unwrap() {
        let jl_best_source = parse_configs_set(&case["best_source"]);

        let sg_data: serde_json::Value =
            serde_json::from_str(include_str!("../../tests/data/jl/spinglass.json")).unwrap();
        let inst = &sg_data["instances"][0]["instance"];
        let nv = inst["num_vertices"].as_u64().unwrap() as usize;
        let edges = parse_edges(inst);
        let j_values = parse_i32_vec(&inst["J"]);
        let h_values = parse_i32_vec(&inst["h"]);

        let interactions: Vec<((usize, usize), i32)> =
            edges.into_iter().zip(j_values).collect();
        let source = SpinGlass::<SimpleGraph, i32>::new(nv, interactions, h_values);

        let result = ReduceTo::<MaxCut<SimpleGraph, i32>>::reduce_to(&source);
        let target = result.target_problem();

        let solver = BruteForce::new();
        let best_target = solver.find_all_best(target);
        let best_source = solver.find_all_best(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();

        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();

        assert!(extracted.is_subset(&best_source_set));
        assert_eq!(best_source_set, jl_best_source, "Best source mismatch");
    }
}

#[test]
fn test_jl_parity_maxcut_to_spinglass() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/maxcut_to_spinglass.json")).unwrap();

    for case in data["cases"].as_array().unwrap() {
        let jl_best_source = parse_configs_set(&case["best_source"]);

        let mc_data: serde_json::Value =
            serde_json::from_str(include_str!("../../tests/data/jl/maxcut.json")).unwrap();
        let inst = &mc_data["instances"][0]["instance"];
        let nv = inst["num_vertices"].as_u64().unwrap() as usize;
        let weighted_edges = parse_weighted_edges(inst);
        let source = MaxCut::<SimpleGraph, i32>::new(nv, weighted_edges);

        let result = ReduceTo::<SpinGlass<SimpleGraph, i32>>::reduce_to(&source);
        let target = result.target_problem();

        let solver = BruteForce::new();
        let best_target = solver.find_all_best(target);
        let best_source = solver.find_all_best(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();

        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();

        assert!(extracted.is_subset(&best_source_set));
        assert_eq!(best_source_set, jl_best_source, "Best source mismatch");
    }
}

#[test]
fn test_jl_parity_spinglass_to_qubo() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/spinglass_to_qubo.json")).unwrap();

    for case in data["cases"].as_array().unwrap() {
        let jl_best_source = parse_configs_set(&case["best_source"]);

        let sg_data: serde_json::Value =
            serde_json::from_str(include_str!("../../tests/data/jl/spinglass.json")).unwrap();
        let inst = &sg_data["instances"][0]["instance"];
        let nv = inst["num_vertices"].as_u64().unwrap() as usize;
        let edges = parse_edges(inst);
        let j_values: Vec<f64> = inst["J"]
            .as_array()
            .unwrap()
            .iter()
            .map(|v| v.as_i64().unwrap() as f64)
            .collect();
        let h_values: Vec<f64> = inst["h"]
            .as_array()
            .unwrap()
            .iter()
            .map(|v| v.as_i64().unwrap() as f64)
            .collect();

        let interactions: Vec<((usize, usize), f64)> =
            edges.into_iter().zip(j_values).collect();
        let source = SpinGlass::<SimpleGraph, f64>::new(nv, interactions, h_values);

        let result = ReduceTo::<QUBO<f64>>::reduce_to(&source);
        let target = result.target_problem();

        let solver = BruteForce::new();
        let best_target = solver.find_all_best(target);
        let best_source = solver.find_all_best(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();

        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();

        assert!(extracted.is_subset(&best_source_set));
        assert_eq!(best_source_set, jl_best_source, "Best source mismatch");
    }
}

#[test]
fn test_jl_parity_qubo_to_spinglass() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/qubo_to_spinglass.json")).unwrap();

    for case in data["cases"].as_array().unwrap() {
        let jl_best_source = parse_configs_set(&case["best_source"]);

        let q_data: serde_json::Value =
            serde_json::from_str(include_str!("../../tests/data/jl/qubo.json")).unwrap();
        let jl_matrix: Vec<Vec<f64>> = q_data["instances"][0]["instance"]["matrix"]
            .as_array()
            .unwrap()
            .iter()
            .map(|row| {
                row.as_array()
                    .unwrap()
                    .iter()
                    .map(|v| v.as_i64().unwrap() as f64)
                    .collect()
            })
            .collect();
        let n = jl_matrix.len();
        let mut rust_matrix = vec![vec![0.0f64; n]; n];
        for i in 0..n {
            rust_matrix[i][i] = jl_matrix[i][i];
            for j in (i + 1)..n {
                rust_matrix[i][j] = jl_matrix[i][j] + jl_matrix[j][i];
            }
        }
        let source = QUBO::from_matrix(rust_matrix);

        let result = ReduceTo::<SpinGlass<SimpleGraph, f64>>::reduce_to(&source);
        let target = result.target_problem();

        let solver = BruteForce::new();
        let best_target = solver.find_all_best(target);
        let best_source = solver.find_all_best(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();

        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();

        assert!(extracted.is_subset(&best_source_set));
        assert_eq!(best_source_set, jl_best_source, "Best source mismatch");
    }
}

#[test]
fn test_jl_parity_sat_to_ksat() {
    let data: serde_json::Value = serde_json::from_str(include_str!(
        "../../tests/data/jl/satisfiability_to_ksatisfiability3.json"
    ))
    .unwrap();

    for case in data["cases"].as_array().unwrap() {
        let jl_best_source = parse_configs_set(&case["best_source"]);

        let sat_data: serde_json::Value =
            serde_json::from_str(include_str!("../../tests/data/jl/satisfiability.json")).unwrap();
        let inst = &sat_data["instances"][0]["instance"];
        let (num_vars, clauses) = parse_sat_clauses(inst);
        let source = Satisfiability::new(num_vars, clauses);

        let result = ReduceTo::<KSatisfiability<3>>::reduce_to(&source);
        let target = result.target_problem();

        let solver = BruteForce::new();
        let best_target = solver.find_all_satisfying(target);
        let best_source = solver.find_all_satisfying(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();

        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();

        assert!(extracted.is_subset(&best_source_set));
        assert_eq!(best_source_set, jl_best_source, "Best source mismatch");
    }
}

#[test]
fn test_jl_parity_ksat_to_sat() {
    let data: serde_json::Value = serde_json::from_str(include_str!(
        "../../tests/data/jl/ksatisfiability_to_satisfiability.json"
    ))
    .unwrap();

    for case in data["cases"].as_array().unwrap() {
        let jl_best_source = parse_configs_set(&case["best_source"]);

        let ksat_data: serde_json::Value =
            serde_json::from_str(include_str!("../../tests/data/jl/ksatisfiability.json")).unwrap();
        let inst = &ksat_data["instances"][0]["instance"];
        let (num_vars, clauses) = parse_sat_clauses(inst);
        let source = KSatisfiability::<3>::new(num_vars, clauses);

        let result = ReduceTo::<Satisfiability>::reduce_to(&source);
        let target = result.target_problem();

        let solver = BruteForce::new();
        let best_target = solver.find_all_satisfying(target);
        let best_source = solver.find_all_satisfying(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();

        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();

        assert!(extracted.is_subset(&best_source_set));
        assert_eq!(best_source_set, jl_best_source, "Best source mismatch");
    }
}

#[test]
fn test_jl_parity_circuitsat_to_spinglass() {
    let a = BooleanExpr::var("a");
    let b = BooleanExpr::var("b");
    let c = BooleanExpr::var("c");

    let x_expr = BooleanExpr::or(vec![a.clone(), BooleanExpr::not(b.clone())]);
    let y_expr = BooleanExpr::or(vec![BooleanExpr::not(c.clone()), b.clone()]);
    let z_expr = BooleanExpr::and(vec![
        BooleanExpr::var("x"),
        BooleanExpr::var("y"),
        a.clone(),
    ]);

    let circuit = Circuit::new(vec![
        Assignment::new(vec!["x".to_string()], x_expr),
        Assignment::new(vec!["y".to_string()], y_expr),
        Assignment::new(vec!["z".to_string()], z_expr),
    ]);
    let source = CircuitSAT::new(circuit);

    let result = ReduceTo::<SpinGlass<SimpleGraph, i32>>::reduce_to(&source);
    let target = result.target_problem();

    let solver = BruteForce::new();
    let best_target = solver.find_all_best(target);
    let best_source = solver.find_all_satisfying(&source);

    let extracted: HashSet<Vec<usize>> = best_target
        .iter()
        .map(|t| result.extract_solution(t))
        .collect();

    let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();
    assert!(
        extracted.is_subset(&best_source_set),
        "CircuitSAT->SpinGlass: extracted solutions should be satisfying"
    );
}

#[test]
fn test_jl_parity_factoring_to_circuitsat() {
    let source = Factoring::new(1, 1, 1);

    let result = ReduceTo::<CircuitSAT>::reduce_to(&source);
    let target = result.target_problem();

    let solver = BruteForce::new();
    let best_target = solver.find_all_satisfying(target);

    let extracted: Vec<Vec<usize>> = best_target
        .iter()
        .map(|t| result.extract_solution(t))
        .collect();

    for sol in &extracted {
        let eval = source.evaluate(sol);
        assert_eq!(
            eval.unwrap(),
            0,
            "Factoring extracted solution {:?} should be valid",
            sol
        );
    }

    let data: serde_json::Value = serde_json::from_str(include_str!(
        "../../tests/data/jl/factoring_to_circuitsat.json"
    ))
    .unwrap();
    let jl_best_source = parse_configs_set(&data["cases"][0]["best_source"]);

    let best_source = BruteForce::new().find_all_best(&source);
    let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();
    assert_eq!(
        best_source_set, jl_best_source,
        "Factoring best source mismatch"
    );
}

// ── Doc example: reduction test ─────────────────────────────────────

#[test]
fn test_jl_parity_doc_independentset_to_setpacking() {
    let data: serde_json::Value = serde_json::from_str(include_str!(
        "../../tests/data/jl/doc_independentset_to_setpacking.json"
    ))
    .unwrap();

    let is_data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/independentset.json")).unwrap();

    for case in data["cases"].as_array().unwrap() {
        let is_instance = is_data["instances"]
            .as_array()
            .unwrap()
            .iter()
            .find(|inst| inst["label"].as_str().unwrap() == "doc_4vertex")
            .expect("doc_4vertex instance not found in independentset.json");

        let nv = is_instance["instance"]["num_vertices"].as_u64().unwrap() as usize;
        let edges = parse_edges(&is_instance["instance"]);
        let source = MaximumIndependentSet::<SimpleGraph, i32>::new(nv, edges);

        let result = ReduceTo::<MaximumSetPacking<i32>>::reduce_to(&source);
        let target = result.target_problem();

        let solver = BruteForce::new();
        let best_target = solver.find_all_best(target);
        let best_source = solver.find_all_best(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();
        let jl_best_source = parse_configs_set(&case["best_source"]);
        assert_eq!(
            best_source_set, jl_best_source,
            "Doc IS->SP: source best solutions mismatch"
        );

        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();
        assert!(
            extracted.is_subset(&best_source_set),
            "Doc IS->SP: extracted solutions not subset of best source"
        );
    }
}

// ── Rule reduction tests: individual rule test instances ─────────────

#[test]
fn test_jl_parity_rule_maxcut_to_spinglass() {
    let data: serde_json::Value = serde_json::from_str(include_str!(
        "../../tests/data/jl/rule_maxcut_to_spinglass.json"
    ))
    .unwrap();
    let mc_data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/maxcut.json")).unwrap();
    let inst = &find_instance_by_label(&mc_data, "rule_4vertex")["instance"];
    let source = MaxCut::<SimpleGraph, i32>::new(
        inst["num_vertices"].as_u64().unwrap() as usize,
        parse_weighted_edges(inst),
    );
    let result = ReduceTo::<SpinGlass<SimpleGraph, i32>>::reduce_to(&source);
    let solver = BruteForce::new();
    let best_target = solver.find_all_best(result.target_problem());
    let best_source: HashSet<Vec<usize>> = solver.find_all_best(&source).into_iter().collect();
    let extracted: HashSet<Vec<usize>> = best_target
        .iter()
        .map(|t| result.extract_solution(t))
        .collect();
    assert!(extracted.is_subset(&best_source));
    for case in data["cases"].as_array().unwrap() {
        assert_eq!(best_source, parse_configs_set(&case["best_source"]));
    }
}

#[test]
fn test_jl_parity_rule_spinglass_to_maxcut() {
    let data: serde_json::Value = serde_json::from_str(include_str!(
        "../../tests/data/jl/rule_spinglass_to_maxcut.json"
    ))
    .unwrap();
    let sg_data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/spinglass.json")).unwrap();
    let inst = &find_instance_by_label(&sg_data, "rule_4vertex")["instance"];
    let nv = inst["num_vertices"].as_u64().unwrap() as usize;
    let edges = parse_edges(inst);
    let j_values = parse_i32_vec(&inst["J"]);
    let h_values = parse_i32_vec(&inst["h"]);
    let interactions: Vec<((usize, usize), i32)> = edges.into_iter().zip(j_values).collect();
    let source = SpinGlass::<SimpleGraph, i32>::new(nv, interactions, h_values);
    let result = ReduceTo::<MaxCut<SimpleGraph, i32>>::reduce_to(&source);
    let solver = BruteForce::new();
    let best_target = solver.find_all_best(result.target_problem());
    let best_source: HashSet<Vec<usize>> = solver.find_all_best(&source).into_iter().collect();
    let extracted: HashSet<Vec<usize>> = best_target
        .iter()
        .map(|t| result.extract_solution(t))
        .collect();
    assert!(extracted.is_subset(&best_source));
    // h=0 so spin convention is symmetric -- no flip needed
    for case in data["cases"].as_array().unwrap() {
        assert_eq!(best_source, parse_configs_set(&case["best_source"]));
    }
}

#[test]
fn test_jl_parity_rule_qubo_to_spinglass() {
    let data: serde_json::Value = serde_json::from_str(include_str!(
        "../../tests/data/jl/rule_qubo_to_spinglass.json"
    ))
    .unwrap();
    let q_data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/qubo.json")).unwrap();
    let jl_matrix: Vec<Vec<f64>> = find_instance_by_label(&q_data, "rule_3x3")["instance"]
        ["matrix"]
        .as_array()
        .unwrap()
        .iter()
        .map(|row| {
            row.as_array()
                .unwrap()
                .iter()
                .map(|v| v.as_f64().unwrap())
                .collect()
        })
        .collect();
    let n = jl_matrix.len();
    let mut rust_matrix = vec![vec![0.0f64; n]; n];
    for i in 0..n {
        rust_matrix[i][i] = jl_matrix[i][i];
        for j in (i + 1)..n {
            rust_matrix[i][j] = jl_matrix[i][j] + jl_matrix[j][i];
        }
    }
    let source = QUBO::from_matrix(rust_matrix);
    let result = ReduceTo::<SpinGlass<SimpleGraph, f64>>::reduce_to(&source);
    let solver = BruteForce::new();
    let best_target = solver.find_all_best(result.target_problem());
    let best_source: HashSet<Vec<usize>> = solver.find_all_best(&source).into_iter().collect();
    let extracted: HashSet<Vec<usize>> = best_target
        .iter()
        .map(|t| result.extract_solution(t))
        .collect();
    assert!(extracted.is_subset(&best_source));
    for case in data["cases"].as_array().unwrap() {
        assert_eq!(best_source, parse_configs_set(&case["best_source"]));
    }
}

#[test]
fn test_jl_parity_rule_vertexcovering_to_setcovering() {
    let data: serde_json::Value = serde_json::from_str(include_str!(
        "../../tests/data/jl/rule_vertexcovering_to_setcovering.json"
    ))
    .unwrap();
    let vc_data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/vertexcovering.json")).unwrap();
    let inst = &find_instance_by_label(&vc_data, "rule_4vertex")["instance"];
    let source = MinimumVertexCover::with_weights(
        inst["num_vertices"].as_u64().unwrap() as usize,
        parse_edges(inst),
        parse_i32_vec(&inst["weights"]),
    );
    let result = ReduceTo::<MinimumSetCovering<i32>>::reduce_to(&source);
    let solver = BruteForce::new();
    let best_target = solver.find_all_best(result.target_problem());
    let best_source: HashSet<Vec<usize>> = solver.find_all_best(&source).into_iter().collect();
    let extracted: HashSet<Vec<usize>> = best_target
        .iter()
        .map(|t| result.extract_solution(t))
        .collect();
    assert!(extracted.is_subset(&best_source));
    for case in data["cases"].as_array().unwrap() {
        assert_eq!(best_source, parse_configs_set(&case["best_source"]));
    }
}

#[test]
fn test_jl_parity_rule_independentset_to_setpacking() {
    let data: serde_json::Value = serde_json::from_str(include_str!(
        "../../tests/data/jl/rule_independentset_to_setpacking.json"
    ))
    .unwrap();
    let is_data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/independentset.json")).unwrap();
    let inst = &find_instance_by_label(&is_data, "doc_4vertex")["instance"];
    let source = MaximumIndependentSet::<SimpleGraph, i32>::new(
        inst["num_vertices"].as_u64().unwrap() as usize,
        parse_edges(inst),
    );
    let result = ReduceTo::<MaximumSetPacking<i32>>::reduce_to(&source);
    let solver = BruteForce::new();
    let best_target = solver.find_all_best(result.target_problem());
    let best_source: HashSet<Vec<usize>> = solver.find_all_best(&source).into_iter().collect();
    let extracted: HashSet<Vec<usize>> = best_target
        .iter()
        .map(|t| result.extract_solution(t))
        .collect();
    assert!(extracted.is_subset(&best_source));
    for case in data["cases"].as_array().unwrap() {
        assert_eq!(best_source, parse_configs_set(&case["best_source"]));
    }
}

#[test]
fn test_jl_parity_rule_independentset_to_vertexcovering() {
    let data: serde_json::Value = serde_json::from_str(include_str!(
        "../../tests/data/jl/rule2_independentset_to_vertexcovering.json"
    ))
    .unwrap();
    let is_data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/independentset.json")).unwrap();
    let inst = &find_instance_by_label(&is_data, "doc_4vertex")["instance"];
    let source = MaximumIndependentSet::<SimpleGraph, i32>::new(
        inst["num_vertices"].as_u64().unwrap() as usize,
        parse_edges(inst),
    );
    let result = ReduceTo::<MinimumVertexCover<SimpleGraph, i32>>::reduce_to(&source);
    let solver = BruteForce::new();
    let best_target = solver.find_all_best(result.target_problem());
    let best_source: HashSet<Vec<usize>> = solver.find_all_best(&source).into_iter().collect();
    let extracted: HashSet<Vec<usize>> = best_target
        .iter()
        .map(|t| result.extract_solution(t))
        .collect();
    assert!(extracted.is_subset(&best_source));
    for case in data["cases"].as_array().unwrap() {
        assert_eq!(best_source, parse_configs_set(&case["best_source"]));
    }
}

#[test]
fn test_jl_parity_matching_to_setpacking() {
    let match_data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/matching.json")).unwrap();
    let fixtures: &[(&str, &str)] = &[
        (
            include_str!("../../tests/data/jl/matching_to_setpacking.json"),
            "petersen",
        ),
        (
            include_str!("../../tests/data/jl/rule_matching_to_setpacking.json"),
            "rule_4vertex",
        ),
        (
            include_str!("../../tests/data/jl/rule_matchingw_to_setpacking.json"),
            "rule_4vertex_weighted",
        ),
    ];
    for (fixture_str, label) in fixtures {
        let data: serde_json::Value = serde_json::from_str(fixture_str).unwrap();
        let inst = &find_instance_by_label(&match_data, label)["instance"];
        let source = MaximumMatching::<SimpleGraph, i32>::new(
            inst["num_vertices"].as_u64().unwrap() as usize,
            parse_weighted_edges(inst),
        );
        let result = ReduceTo::<MaximumSetPacking<i32>>::reduce_to(&source);
        let solver = BruteForce::new();
        let best_target = solver.find_all_best(result.target_problem());
        let best_source: HashSet<Vec<usize>> =
            solver.find_all_best(&source).into_iter().collect();
        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();
        assert!(
            extracted.is_subset(&best_source),
            "Matching->SP [{label}]: extracted not subset of best source"
        );
        for case in data["cases"].as_array().unwrap() {
            assert_eq!(
                best_source,
                parse_configs_set(&case["best_source"]),
                "Matching->SP [{label}]: best source mismatch"
            );
        }
    }
}

#[test]
fn test_jl_parity_rule_sat_to_ksat() {
    let data: serde_json::Value = serde_json::from_str(include_str!(
        "../../tests/data/jl/rule_satisfiability_to_ksatisfiability3.json"
    ))
    .unwrap();
    let sat_data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/satisfiability.json")).unwrap();
    let inst = &find_instance_by_label(&sat_data, "rule_3sat_multi")["instance"];
    let (num_vars, clauses) = parse_sat_clauses(inst);
    let source = Satisfiability::new(num_vars, clauses);
    let result = ReduceTo::<KSatisfiability<3>>::reduce_to(&source);
    let solver = BruteForce::new();
    let best_target = solver.find_all_satisfying(result.target_problem());
    let best_source: HashSet<Vec<usize>> =
        solver.find_all_satisfying(&source).into_iter().collect();
    let extracted: HashSet<Vec<usize>> = best_target
        .iter()
        .map(|t| result.extract_solution(t))
        .collect();
    assert!(extracted.is_subset(&best_source));
    for case in data["cases"].as_array().unwrap() {
        assert_eq!(best_source, parse_configs_set(&case["best_source"]));
    }
}

#[test]
fn test_jl_parity_sat_to_coloring() {
    let sat_data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/satisfiability.json")).unwrap();
    let fixtures: &[(&str, &str)] = &[
        (
            include_str!("../../tests/data/jl/satisfiability_to_coloring3.json"),
            "simple_clause",
        ),
        (
            include_str!("../../tests/data/jl/rule_satisfiability2_to_coloring3.json"),
            "rule_sat_coloring",
        ),
    ];
    for (fixture_str, label) in fixtures {
        let data: serde_json::Value = serde_json::from_str(fixture_str).unwrap();
        let inst = &find_instance_by_label(&sat_data, label)["instance"];
        let (num_vars, clauses) = parse_sat_clauses(inst);
        let source = Satisfiability::new(num_vars, clauses);
        let result = ReduceTo::<KColoring<3, SimpleGraph>>::reduce_to(&source);
        // Use ILP solver for the KColoring target (brute force is too slow)
        let ilp_solver = ILPSolver::new();
        let target = result.target_problem();
        let target_sol = ilp_solver
            .solve_reduced(target)
            .expect("ILP should find a coloring");
        let extracted = result.extract_solution(&target_sol);
        let best_source: HashSet<Vec<usize>> = BruteForce::new()
            .find_all_satisfying(&source)
            .into_iter()
            .collect();
        assert!(
            best_source.contains(&extracted),
            "SAT->Coloring [{label}]: extracted solution not satisfying"
        );
        for case in data["cases"].as_array().unwrap() {
            assert_eq!(
                best_source,
                parse_configs_set(&case["best_source"]),
                "SAT->Coloring [{label}]: best source mismatch"
            );
        }
    }
}

#[test]
fn test_jl_parity_sat_to_independentset() {
    let sat_data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/satisfiability.json")).unwrap();
    let fixtures: &[(&str, &str)] = &[
        (
            include_str!("../../tests/data/jl/satisfiability_to_independentset.json"),
            "simple_clause",
        ),
        (
            include_str!("../../tests/data/jl/rule_sat01_to_independentset.json"),
            "rule_sat01",
        ),
        (
            include_str!("../../tests/data/jl/rule_sat02_to_independentset.json"),
            "rule_sat02",
        ),
        (
            include_str!("../../tests/data/jl/rule_sat03_to_independentset.json"),
            "rule_sat03",
        ),
        (
            include_str!("../../tests/data/jl/rule_sat04_unsat_to_independentset.json"),
            "rule_sat04_unsat",
        ),
        (
            include_str!("../../tests/data/jl/rule_sat07_to_independentset.json"),
            "rule_sat07",
        ),
    ];
    for (fixture_str, label) in fixtures {
        let data: serde_json::Value = serde_json::from_str(fixture_str).unwrap();
        let inst = &find_instance_by_label(&sat_data, label)["instance"];
        let (num_vars, clauses) = parse_sat_clauses(inst);
        let source = Satisfiability::new(num_vars, clauses);
        let result =
            ReduceTo::<MaximumIndependentSet<SimpleGraph, i32>>::reduce_to(&source);
        let solver = BruteForce::new();
        let best_target = solver.find_all_best(result.target_problem());
        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();
        let sat_solutions: HashSet<Vec<usize>> =
            solver.find_all_satisfying(&source).into_iter().collect();
        for case in data["cases"].as_array().unwrap() {
            if sat_solutions.is_empty() {
                // Unsatisfiable: verify reduction runs; extracted won't satisfy source
                for sol in &extracted {
                    assert!(
                        !source.evaluate(sol),
                        "SAT->IS [{label}]: unsatisfiable but extracted solution satisfies"
                    );
                }
            } else {
                assert!(
                    extracted.is_subset(&sat_solutions),
                    "SAT->IS [{label}]: extracted not subset of satisfying"
                );
                assert_eq!(
                    sat_solutions,
                    parse_configs_set(&case["best_source"]),
                    "SAT->IS [{label}]: best source mismatch"
                );
            }
        }
    }
}

#[test]
fn test_jl_parity_sat_to_dominatingset() {
    let sat_data: serde_json::Value =
        serde_json::from_str(include_str!("../../tests/data/jl/satisfiability.json")).unwrap();
    let fixtures: &[(&str, &str)] = &[
        (
            include_str!("../../tests/data/jl/satisfiability_to_dominatingset.json"),
            "simple_clause",
        ),
        (
            include_str!("../../tests/data/jl/rule_sat01_to_dominatingset.json"),
            "rule_sat01",
        ),
        (
            include_str!("../../tests/data/jl/rule_sat02_to_dominatingset.json"),
            "rule_sat02",
        ),
        (
            include_str!("../../tests/data/jl/rule_sat03_to_dominatingset.json"),
            "rule_sat03",
        ),
        (
            include_str!("../../tests/data/jl/rule_sat04_unsat_to_dominatingset.json"),
            "rule_sat04_unsat",
        ),
        (
            include_str!("../../tests/data/jl/rule_sat07_to_dominatingset.json"),
            "rule_sat07",
        ),
    ];
    for (fixture_str, label) in fixtures {
        let data: serde_json::Value = serde_json::from_str(fixture_str).unwrap();
        let inst = &find_instance_by_label(&sat_data, label)["instance"];
        let (num_vars, clauses) = parse_sat_clauses(inst);
        let source = Satisfiability::new(num_vars, clauses);
        let result =
            ReduceTo::<MinimumDominatingSet<SimpleGraph, i32>>::reduce_to(&source);
        let solver = BruteForce::new();
        let best_target = solver.find_all_best(result.target_problem());
        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();
        let sat_solutions: HashSet<Vec<usize>> =
            solver.find_all_satisfying(&source).into_iter().collect();
        for case in data["cases"].as_array().unwrap() {
            if sat_solutions.is_empty() {
                for sol in &extracted {
                    assert!(
                        !source.evaluate(sol),
                        "SAT->DS [{label}]: unsatisfiable but extracted solution satisfies"
                    );
                }
            } else {
                assert!(
                    extracted.is_subset(&sat_solutions),
                    "SAT->DS [{label}]: extracted not subset of satisfying"
                );
                assert_eq!(
                    sat_solutions,
                    parse_configs_set(&case["best_source"]),
                    "SAT->DS [{label}]: best source mismatch"
                );
            }
        }
    }
}

#[test]
#[ignore] // SAT -> CircuitSAT not yet implemented in Rust
fn test_jl_parity_rule_sat_to_circuitsat() {}

//! Tests that verify Rust gadget implementations match Julia ground truth.
//!
//! The ground truth is generated by scripts/dump_gadgets.jl and stored in
//! tests/julia/gadgets_ground_truth.json

use problemreductions::rules::unitdiskmapping::{
    // Unweighted square gadgets
    Branch,
    BranchFix,
    BranchFixB,
    Cross,
    DanglingLeg,
    EndTurn,
    Mirror,
    Pattern,
    ReflectedGadget,
    RotatedGadget,
    TCon,
    // Triangular gadgets
    TriBranch,
    TriBranchFix,
    TriBranchFixB,
    TriCross,
    TriEndTurn,
    TriTConDown,
    TriTConLeft,
    TriTConUp,
    TriTrivialTurnLeft,
    TriTrivialTurnRight,
    TriTurn,
    TriWTurn,
    TriangularGadget,
    TrivialTurn,
    Turn,
    WTurn,
};
use serde::Deserialize;
use std::collections::HashMap;
use std::fs;

#[derive(Debug, Deserialize)]
#[allow(dead_code)]
struct GadgetData {
    name: String,
    size: Vec<usize>,
    cross_location: Vec<usize>,
    mis_overhead: i32,
    source_nodes: usize,
    mapped_nodes: usize,
    source_locs: Vec<Vec<usize>>,
    mapped_locs: Vec<Vec<usize>>,
    #[serde(default)]
    source_weights: Vec<i32>,
    #[serde(default)]
    mapped_weights: Vec<i32>,
    #[serde(default)]
    source_centers: Vec<Vec<usize>>,
    #[serde(default)]
    mapped_centers: Vec<Vec<usize>>,
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)]
struct GroundTruth {
    unweighted_square: Vec<GadgetData>,
    triangular: Vec<GadgetData>,
    weighted_square: Vec<GadgetData>,
    weighted_triangular: Vec<GadgetData>,
    rotated: Vec<GadgetData>,
    reflected: Vec<GadgetData>,
}

fn load_ground_truth() -> GroundTruth {
    let path = concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/tests/julia/gadgets_ground_truth.json"
    );
    let content = fs::read_to_string(path).expect("Failed to read ground truth file");
    serde_json::from_str(&content).expect("Failed to parse ground truth JSON")
}

fn to_map(gadgets: &[GadgetData]) -> HashMap<String, &GadgetData> {
    gadgets.iter().map(|g| (g.name.clone(), g)).collect()
}

macro_rules! check_gadget {
    ($name:expr, $gadget:expr, $expected:expr) => {{
        let g = $gadget;
        let e = $expected;

        // Check size
        assert_eq!(g.size(), (e.size[0], e.size[1]), "{}: size mismatch", $name);

        // Check cross_location
        assert_eq!(
            g.cross_location(),
            (e.cross_location[0], e.cross_location[1]),
            "{}: cross_location mismatch",
            $name
        );

        // Check mis_overhead
        assert_eq!(
            g.mis_overhead(),
            e.mis_overhead,
            "{}: mis_overhead mismatch",
            $name
        );

        // Check source graph node count
        let (slocs, _, _) = g.source_graph();
        assert_eq!(
            slocs.len(),
            e.source_nodes,
            "{}: source_nodes count mismatch",
            $name
        );

        // Check mapped graph node count
        let (mlocs, _) = g.mapped_graph();
        assert_eq!(
            mlocs.len(),
            e.mapped_nodes,
            "{}: mapped_nodes count mismatch",
            $name
        );

        // Check source locations match (as sets, order may differ)
        let rust_slocs: std::collections::HashSet<_> = slocs.iter().cloned().collect();
        let julia_slocs: std::collections::HashSet<_> =
            e.source_locs.iter().map(|v| (v[0], v[1])).collect();
        assert_eq!(
            rust_slocs, julia_slocs,
            "{}: source_locs mismatch\nRust: {:?}\nJulia: {:?}",
            $name, rust_slocs, julia_slocs
        );

        // Check mapped locations match (as sets, order may differ)
        let rust_mlocs: std::collections::HashSet<_> = mlocs.iter().cloned().collect();
        let julia_mlocs: std::collections::HashSet<_> =
            e.mapped_locs.iter().map(|v| (v[0], v[1])).collect();
        assert_eq!(
            rust_mlocs, julia_mlocs,
            "{}: mapped_locs mismatch\nRust: {:?}\nJulia: {:?}",
            $name, rust_mlocs, julia_mlocs
        );
    }};
}

macro_rules! check_weighted_gadget {
    ($name:expr, $gadget:expr, $expected:expr) => {{
        let g = $gadget;
        let e = $expected;

        // Check size
        assert_eq!(g.size(), (e.size[0], e.size[1]), "{}: size mismatch", $name);

        // Check cross_location
        assert_eq!(
            g.cross_location(),
            (e.cross_location[0], e.cross_location[1]),
            "{}: cross_location mismatch",
            $name
        );

        // Note: We skip mis_overhead check for weighted gadgets because
        // Julia's WeightedGadget has different mis_overhead than the base gadget,
        // but Rust doesn't have a separate WeightedGadget type.

        // Check source graph node count
        let (slocs, _, _) = g.source_graph();
        assert_eq!(
            slocs.len(),
            e.source_nodes,
            "{}: source_nodes count mismatch",
            $name
        );

        // Check mapped graph node count
        let (mlocs, _) = g.mapped_graph();
        assert_eq!(
            mlocs.len(),
            e.mapped_nodes,
            "{}: mapped_nodes count mismatch",
            $name
        );

        // Check source locations match (as sets, order may differ)
        let rust_slocs: std::collections::HashSet<_> = slocs.iter().cloned().collect();
        let julia_slocs: std::collections::HashSet<_> =
            e.source_locs.iter().map(|v| (v[0], v[1])).collect();
        assert_eq!(
            rust_slocs, julia_slocs,
            "{}: source_locs mismatch\nRust: {:?}\nJulia: {:?}",
            $name, rust_slocs, julia_slocs
        );

        // Check mapped locations match (as sets, order may differ)
        let rust_mlocs: std::collections::HashSet<_> = mlocs.iter().cloned().collect();
        let julia_mlocs: std::collections::HashSet<_> =
            e.mapped_locs.iter().map(|v| (v[0], v[1])).collect();
        assert_eq!(
            rust_mlocs, julia_mlocs,
            "{}: mapped_locs mismatch\nRust: {:?}\nJulia: {:?}",
            $name, rust_mlocs, julia_mlocs
        );

        // Check source weights
        let sw = g.source_weights();
        assert_eq!(
            sw, e.source_weights,
            "{}: source_weights mismatch\nRust: {:?}\nJulia: {:?}",
            $name, sw, e.source_weights
        );

        // Check mapped weights
        let mw = g.mapped_weights();
        assert_eq!(
            mw, e.mapped_weights,
            "{}: mapped_weights mismatch\nRust: {:?}\nJulia: {:?}",
            $name, mw, e.mapped_weights
        );
    }};
}

// === Unweighted Square Gadget Tests ===

#[test]
fn test_unweighted_square_cross_false() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("Cross_false", Cross::<false>, map["Cross_false"]);
}

#[test]
fn test_unweighted_square_cross_true() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("Cross_true", Cross::<true>, map["Cross_true"]);
}

#[test]
fn test_unweighted_square_turn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("Turn", Turn, map["Turn"]);
}

#[test]
fn test_unweighted_square_wturn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("WTurn", WTurn, map["WTurn"]);
}

#[test]
fn test_unweighted_square_branch() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("Branch", Branch, map["Branch"]);
}

#[test]
fn test_unweighted_square_branchfix() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("BranchFix", BranchFix, map["BranchFix"]);
}

#[test]
fn test_unweighted_square_branchfixb() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("BranchFixB", BranchFixB, map["BranchFixB"]);
}

#[test]
fn test_unweighted_square_tcon() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("TCon", TCon, map["TCon"]);
}

#[test]
fn test_unweighted_square_trivialturn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("TrivialTurn", TrivialTurn, map["TrivialTurn"]);
}

#[test]
fn test_unweighted_square_endturn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("EndTurn", EndTurn, map["EndTurn"]);
}

#[test]
fn test_unweighted_square_danglingleg() {
    let gt = load_ground_truth();
    let map = to_map(&gt.unweighted_square);
    check_gadget!("DanglingLeg", DanglingLeg, map["DanglingLeg"]);
}

// === Triangular Gadget Tests ===

#[test]
fn test_triangular_cross_false() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriCross_false", TriCross::<false>, map["TriCross_false"]);
}

#[test]
fn test_triangular_cross_true() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriCross_true", TriCross::<true>, map["TriCross_true"]);
}

#[test]
fn test_triangular_tcon_left() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriTCon_left", TriTConLeft, map["TriTCon_left"]);
}

#[test]
fn test_triangular_tcon_up() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriTCon_up", TriTConUp, map["TriTCon_up"]);
}

#[test]
fn test_triangular_tcon_down() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriTCon_down", TriTConDown, map["TriTCon_down"]);
}

#[test]
fn test_triangular_trivialturn_left() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!(
        "TriTrivialTurn_left",
        TriTrivialTurnLeft,
        map["TriTrivialTurn_left"]
    );
}

#[test]
fn test_triangular_trivialturn_right() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!(
        "TriTrivialTurn_right",
        TriTrivialTurnRight,
        map["TriTrivialTurn_right"]
    );
}

#[test]
fn test_triangular_endturn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriEndTurn", TriEndTurn, map["TriEndTurn"]);
}

#[test]
fn test_triangular_turn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriTurn", TriTurn, map["TriTurn"]);
}

#[test]
fn test_triangular_wturn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriWTurn", TriWTurn, map["TriWTurn"]);
}

#[test]
fn test_triangular_branchfix() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriBranchFix", TriBranchFix, map["TriBranchFix"]);
}

#[test]
fn test_triangular_branchfixb() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriBranchFixB", TriBranchFixB, map["TriBranchFixB"]);
}

#[test]
fn test_triangular_branch() {
    let gt = load_ground_truth();
    let map = to_map(&gt.triangular);
    check_gadget!("TriBranch", TriBranch, map["TriBranch"]);
}

// === Weighted Square Gadget Tests ===

#[test]
fn test_weighted_square_cross_false() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("Cross_false", Cross::<false>, map["Cross_false"]);
}

#[test]
fn test_weighted_square_cross_true() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("Cross_true", Cross::<true>, map["Cross_true"]);
}

#[test]
fn test_weighted_square_turn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("Turn", Turn, map["Turn"]);
}

#[test]
fn test_weighted_square_wturn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("WTurn", WTurn, map["WTurn"]);
}

#[test]
fn test_weighted_square_branch() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("Branch", Branch, map["Branch"]);
}

#[test]
fn test_weighted_square_branchfix() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("BranchFix", BranchFix, map["BranchFix"]);
}

#[test]
fn test_weighted_square_branchfixb() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("BranchFixB", BranchFixB, map["BranchFixB"]);
}

#[test]
fn test_weighted_square_tcon() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("TCon", TCon, map["TCon"]);
}

#[test]
fn test_weighted_square_trivialturn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("TrivialTurn", TrivialTurn, map["TrivialTurn"]);
}

#[test]
fn test_weighted_square_endturn() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("EndTurn", EndTurn, map["EndTurn"]);
}

#[test]
fn test_weighted_square_danglingleg() {
    let gt = load_ground_truth();
    let map = to_map(&gt.weighted_square);
    check_weighted_gadget!("DanglingLeg", DanglingLeg, map["DanglingLeg"]);
}

// === Rotated Gadget Tests ===

macro_rules! test_rotated {
    ($test_name:ident, $base:expr, $n:expr, $key:expr) => {
        #[test]
        fn $test_name() {
            let gt = load_ground_truth();
            let map = to_map(&gt.rotated);
            let gadget = RotatedGadget::new($base, $n);
            check_gadget!($key, gadget, map[$key]);
        }
    };
}

macro_rules! test_reflected {
    ($test_name:ident, $base:expr, $mirror:expr, $key:expr) => {
        #[test]
        fn $test_name() {
            let gt = load_ground_truth();
            let map = to_map(&gt.reflected);
            let gadget = ReflectedGadget::new($base, $mirror);
            check_gadget!($key, gadget, map[$key]);
        }
    };
}

// Cross<false> rotations
test_rotated!(
    test_rotated_cross_false_rot1,
    Cross::<false>,
    1,
    "Cross_false_rot1"
);
test_rotated!(
    test_rotated_cross_false_rot2,
    Cross::<false>,
    2,
    "Cross_false_rot2"
);
test_rotated!(
    test_rotated_cross_false_rot3,
    Cross::<false>,
    3,
    "Cross_false_rot3"
);

// Cross<true> rotations
test_rotated!(
    test_rotated_cross_true_rot1,
    Cross::<true>,
    1,
    "Cross_true_rot1"
);
test_rotated!(
    test_rotated_cross_true_rot2,
    Cross::<true>,
    2,
    "Cross_true_rot2"
);
test_rotated!(
    test_rotated_cross_true_rot3,
    Cross::<true>,
    3,
    "Cross_true_rot3"
);

// Turn rotations
test_rotated!(test_rotated_turn_rot1, Turn, 1, "Turn_rot1");
test_rotated!(test_rotated_turn_rot2, Turn, 2, "Turn_rot2");
test_rotated!(test_rotated_turn_rot3, Turn, 3, "Turn_rot3");

// WTurn rotations
test_rotated!(test_rotated_wturn_rot1, WTurn, 1, "WTurn_rot1");
test_rotated!(test_rotated_wturn_rot2, WTurn, 2, "WTurn_rot2");
test_rotated!(test_rotated_wturn_rot3, WTurn, 3, "WTurn_rot3");

// Branch rotations
test_rotated!(test_rotated_branch_rot1, Branch, 1, "Branch_rot1");
test_rotated!(test_rotated_branch_rot2, Branch, 2, "Branch_rot2");
test_rotated!(test_rotated_branch_rot3, Branch, 3, "Branch_rot3");

// BranchFix rotations
test_rotated!(test_rotated_branchfix_rot1, BranchFix, 1, "BranchFix_rot1");
test_rotated!(test_rotated_branchfix_rot2, BranchFix, 2, "BranchFix_rot2");
test_rotated!(test_rotated_branchfix_rot3, BranchFix, 3, "BranchFix_rot3");

// BranchFixB rotations
test_rotated!(
    test_rotated_branchfixb_rot1,
    BranchFixB,
    1,
    "BranchFixB_rot1"
);
test_rotated!(
    test_rotated_branchfixb_rot2,
    BranchFixB,
    2,
    "BranchFixB_rot2"
);
test_rotated!(
    test_rotated_branchfixb_rot3,
    BranchFixB,
    3,
    "BranchFixB_rot3"
);

// TCon rotations
test_rotated!(test_rotated_tcon_rot1, TCon, 1, "TCon_rot1");
test_rotated!(test_rotated_tcon_rot2, TCon, 2, "TCon_rot2");
test_rotated!(test_rotated_tcon_rot3, TCon, 3, "TCon_rot3");

// TrivialTurn rotations
test_rotated!(
    test_rotated_trivialturn_rot1,
    TrivialTurn,
    1,
    "TrivialTurn_rot1"
);
test_rotated!(
    test_rotated_trivialturn_rot2,
    TrivialTurn,
    2,
    "TrivialTurn_rot2"
);
test_rotated!(
    test_rotated_trivialturn_rot3,
    TrivialTurn,
    3,
    "TrivialTurn_rot3"
);

// EndTurn rotations
test_rotated!(test_rotated_endturn_rot1, EndTurn, 1, "EndTurn_rot1");
test_rotated!(test_rotated_endturn_rot2, EndTurn, 2, "EndTurn_rot2");
test_rotated!(test_rotated_endturn_rot3, EndTurn, 3, "EndTurn_rot3");

// DanglingLeg rotations
test_rotated!(
    test_rotated_danglingleg_rot1,
    DanglingLeg,
    1,
    "DanglingLeg_rot1"
);
test_rotated!(
    test_rotated_danglingleg_rot2,
    DanglingLeg,
    2,
    "DanglingLeg_rot2"
);
test_rotated!(
    test_rotated_danglingleg_rot3,
    DanglingLeg,
    3,
    "DanglingLeg_rot3"
);

// === Reflected Gadget Tests ===

// Cross<false> reflections
test_reflected!(
    test_reflected_cross_false_x,
    Cross::<false>,
    Mirror::X,
    "Cross_false_ref_x"
);
test_reflected!(
    test_reflected_cross_false_y,
    Cross::<false>,
    Mirror::Y,
    "Cross_false_ref_y"
);
test_reflected!(
    test_reflected_cross_false_diag,
    Cross::<false>,
    Mirror::Diag,
    "Cross_false_ref_diag"
);
test_reflected!(
    test_reflected_cross_false_offdiag,
    Cross::<false>,
    Mirror::OffDiag,
    "Cross_false_ref_offdiag"
);

// Cross<true> reflections
test_reflected!(
    test_reflected_cross_true_x,
    Cross::<true>,
    Mirror::X,
    "Cross_true_ref_x"
);
test_reflected!(
    test_reflected_cross_true_y,
    Cross::<true>,
    Mirror::Y,
    "Cross_true_ref_y"
);
test_reflected!(
    test_reflected_cross_true_diag,
    Cross::<true>,
    Mirror::Diag,
    "Cross_true_ref_diag"
);
test_reflected!(
    test_reflected_cross_true_offdiag,
    Cross::<true>,
    Mirror::OffDiag,
    "Cross_true_ref_offdiag"
);

// Turn reflections
test_reflected!(test_reflected_turn_x, Turn, Mirror::X, "Turn_ref_x");
test_reflected!(test_reflected_turn_y, Turn, Mirror::Y, "Turn_ref_y");
test_reflected!(
    test_reflected_turn_diag,
    Turn,
    Mirror::Diag,
    "Turn_ref_diag"
);
test_reflected!(
    test_reflected_turn_offdiag,
    Turn,
    Mirror::OffDiag,
    "Turn_ref_offdiag"
);

// WTurn reflections
test_reflected!(test_reflected_wturn_x, WTurn, Mirror::X, "WTurn_ref_x");
test_reflected!(test_reflected_wturn_y, WTurn, Mirror::Y, "WTurn_ref_y");
test_reflected!(
    test_reflected_wturn_diag,
    WTurn,
    Mirror::Diag,
    "WTurn_ref_diag"
);
test_reflected!(
    test_reflected_wturn_offdiag,
    WTurn,
    Mirror::OffDiag,
    "WTurn_ref_offdiag"
);

// Branch reflections
test_reflected!(test_reflected_branch_x, Branch, Mirror::X, "Branch_ref_x");
test_reflected!(test_reflected_branch_y, Branch, Mirror::Y, "Branch_ref_y");
test_reflected!(
    test_reflected_branch_diag,
    Branch,
    Mirror::Diag,
    "Branch_ref_diag"
);
test_reflected!(
    test_reflected_branch_offdiag,
    Branch,
    Mirror::OffDiag,
    "Branch_ref_offdiag"
);

// BranchFix reflections
test_reflected!(
    test_reflected_branchfix_x,
    BranchFix,
    Mirror::X,
    "BranchFix_ref_x"
);
test_reflected!(
    test_reflected_branchfix_y,
    BranchFix,
    Mirror::Y,
    "BranchFix_ref_y"
);
test_reflected!(
    test_reflected_branchfix_diag,
    BranchFix,
    Mirror::Diag,
    "BranchFix_ref_diag"
);
test_reflected!(
    test_reflected_branchfix_offdiag,
    BranchFix,
    Mirror::OffDiag,
    "BranchFix_ref_offdiag"
);

// BranchFixB reflections
test_reflected!(
    test_reflected_branchfixb_x,
    BranchFixB,
    Mirror::X,
    "BranchFixB_ref_x"
);
test_reflected!(
    test_reflected_branchfixb_y,
    BranchFixB,
    Mirror::Y,
    "BranchFixB_ref_y"
);
test_reflected!(
    test_reflected_branchfixb_diag,
    BranchFixB,
    Mirror::Diag,
    "BranchFixB_ref_diag"
);
test_reflected!(
    test_reflected_branchfixb_offdiag,
    BranchFixB,
    Mirror::OffDiag,
    "BranchFixB_ref_offdiag"
);

// TCon reflections
test_reflected!(test_reflected_tcon_x, TCon, Mirror::X, "TCon_ref_x");
test_reflected!(test_reflected_tcon_y, TCon, Mirror::Y, "TCon_ref_y");
test_reflected!(
    test_reflected_tcon_diag,
    TCon,
    Mirror::Diag,
    "TCon_ref_diag"
);
test_reflected!(
    test_reflected_tcon_offdiag,
    TCon,
    Mirror::OffDiag,
    "TCon_ref_offdiag"
);

// TrivialTurn reflections
test_reflected!(
    test_reflected_trivialturn_x,
    TrivialTurn,
    Mirror::X,
    "TrivialTurn_ref_x"
);
test_reflected!(
    test_reflected_trivialturn_y,
    TrivialTurn,
    Mirror::Y,
    "TrivialTurn_ref_y"
);
test_reflected!(
    test_reflected_trivialturn_diag,
    TrivialTurn,
    Mirror::Diag,
    "TrivialTurn_ref_diag"
);
test_reflected!(
    test_reflected_trivialturn_offdiag,
    TrivialTurn,
    Mirror::OffDiag,
    "TrivialTurn_ref_offdiag"
);

// EndTurn reflections
test_reflected!(
    test_reflected_endturn_x,
    EndTurn,
    Mirror::X,
    "EndTurn_ref_x"
);
test_reflected!(
    test_reflected_endturn_y,
    EndTurn,
    Mirror::Y,
    "EndTurn_ref_y"
);
test_reflected!(
    test_reflected_endturn_diag,
    EndTurn,
    Mirror::Diag,
    "EndTurn_ref_diag"
);
test_reflected!(
    test_reflected_endturn_offdiag,
    EndTurn,
    Mirror::OffDiag,
    "EndTurn_ref_offdiag"
);

// DanglingLeg reflections
test_reflected!(
    test_reflected_danglingleg_x,
    DanglingLeg,
    Mirror::X,
    "DanglingLeg_ref_x"
);
test_reflected!(
    test_reflected_danglingleg_y,
    DanglingLeg,
    Mirror::Y,
    "DanglingLeg_ref_y"
);
test_reflected!(
    test_reflected_danglingleg_diag,
    DanglingLeg,
    Mirror::Diag,
    "DanglingLeg_ref_diag"
);
test_reflected!(
    test_reflected_danglingleg_offdiag,
    DanglingLeg,
    Mirror::OffDiag,
    "DanglingLeg_ref_offdiag"
);

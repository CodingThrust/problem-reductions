//! Parity tests verifying Rust implementations match ProblemReductions.jl.
//!
//! These tests load JSON fixtures generated by `scripts/jl/generate_testdata.jl`
//! and compare evaluations, solver results, and reduction outputs.

use problemreductions::models::specialized::{Assignment, BooleanExpr, Circuit};
use problemreductions::prelude::*;
use problemreductions::topology::SimpleGraph;
use std::collections::HashSet;

// ── JSON helpers ────────────────────────────────────────────────────

fn parse_edges(instance: &serde_json::Value) -> Vec<(usize, usize)> {
    instance["edges"]
        .as_array()
        .unwrap()
        .iter()
        .map(|e| {
            let arr = e.as_array().unwrap();
            (
                arr[0].as_u64().unwrap() as usize,
                arr[1].as_u64().unwrap() as usize,
            )
        })
        .collect()
}

fn parse_weighted_edges(instance: &serde_json::Value) -> Vec<(usize, usize, i32)> {
    let edges = parse_edges(instance);
    let weights: Vec<i32> = instance["weights"]
        .as_array()
        .unwrap()
        .iter()
        .map(|w| w.as_i64().unwrap() as i32)
        .collect();
    edges
        .into_iter()
        .zip(weights)
        .map(|((u, v), w)| (u, v, w))
        .collect()
}

fn parse_config(val: &serde_json::Value) -> Vec<usize> {
    val.as_array()
        .unwrap()
        .iter()
        .map(|v| v.as_u64().unwrap() as usize)
        .collect()
}

fn parse_configs_set(val: &serde_json::Value) -> HashSet<Vec<usize>> {
    val.as_array()
        .unwrap()
        .iter()
        .map(parse_config)
        .collect()
}

fn parse_i32_vec(val: &serde_json::Value) -> Vec<i32> {
    val.as_array()
        .unwrap()
        .iter()
        .map(|v| v.as_i64().unwrap() as i32)
        .collect()
}

fn parse_sets(val: &serde_json::Value) -> Vec<Vec<usize>> {
    val.as_array()
        .unwrap()
        .iter()
        .map(|s| {
            s.as_array()
                .unwrap()
                .iter()
                .map(|v| v.as_u64().unwrap() as usize)
                .collect()
        })
        .collect()
}

fn parse_sat_clauses(instance: &serde_json::Value) -> (usize, Vec<CNFClause>) {
    let num_vars = instance["num_variables"].as_u64().unwrap() as usize;
    let clauses: Vec<CNFClause> = instance["clauses"]
        .as_array()
        .unwrap()
        .iter()
        .map(|clause| {
            let literals: Vec<i32> = clause["literals"]
                .as_array()
                .unwrap()
                .iter()
                .map(|lit| {
                    let var = lit["variable"].as_u64().unwrap() as i32 + 1; // Convert to 1-indexed
                    let negated = lit["negated"].as_bool().unwrap();
                    if negated { -var } else { var }
                })
                .collect();
            CNFClause::new(literals)
        })
        .collect();
    (num_vars, clauses)
}

// ── Model evaluation tests ──────────────────────────────────────────

#[test]
fn test_jl_parity_independentset_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../data/jl_independentset.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let nv = instance["instance"]["num_vertices"].as_u64().unwrap() as usize;
        let edges = parse_edges(&instance["instance"]);
        let weights = parse_i32_vec(&instance["instance"]["weights"]);

        let problem = if weights.iter().all(|&w| w == 1) {
            MaximumIndependentSet::<SimpleGraph, i32>::new(nv, edges)
        } else {
            MaximumIndependentSet::with_weights(nv, edges, weights)
        };

        // Check evaluations
        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let result = problem.evaluate(&config);
            let jl_valid = eval["is_valid"].as_bool().unwrap();
            assert_eq!(
                result.is_valid(),
                jl_valid,
                "IS validity mismatch for config {:?}",
                config
            );
            if jl_valid {
                let jl_size = eval["size"].as_i64().unwrap() as i32;
                assert_eq!(
                    result.unwrap(),
                    jl_size,
                    "IS size mismatch for config {:?}",
                    config
                );
            }
        }

        // Check best solutions
        let best = BruteForce::new().find_all_best(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best: HashSet<Vec<usize>> = best.into_iter().collect();
        assert_eq!(rust_best, jl_best, "IS best solutions mismatch");
    }
}

#[test]
fn test_jl_parity_spinglass_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../data/jl_spinglass.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let nv = instance["instance"]["num_vertices"].as_u64().unwrap() as usize;
        let edges = parse_edges(&instance["instance"]);
        let j_values = parse_i32_vec(&instance["instance"]["J"]);
        let h_values = parse_i32_vec(&instance["instance"]["h"]);

        let interactions: Vec<((usize, usize), i32)> = edges
            .into_iter()
            .zip(j_values)
            .collect();

        let problem = SpinGlass::<SimpleGraph, i32>::new(nv, interactions, h_values);

        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let result = problem.evaluate(&config);
            let jl_size = eval["size"].as_i64().unwrap() as i32;
            // SpinGlass always valid
            assert!(
                result.is_valid(),
                "SpinGlass should always be valid, config {:?}",
                config
            );
            assert_eq!(
                result.unwrap(),
                jl_size,
                "SpinGlass energy mismatch for config {:?}: rust={}, jl={}",
                config,
                result.unwrap(),
                jl_size
            );
        }

        let best = BruteForce::new().find_all_best(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best: HashSet<Vec<usize>> = best.into_iter().collect();
        assert_eq!(rust_best, jl_best, "SpinGlass best solutions mismatch");
    }
}

#[test]
fn test_jl_parity_maxcut_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../data/jl_maxcut.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let nv = instance["instance"]["num_vertices"].as_u64().unwrap() as usize;
        let weighted_edges = parse_weighted_edges(&instance["instance"]);

        let problem = MaxCut::<SimpleGraph, i32>::new(nv, weighted_edges);

        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let result = problem.evaluate(&config);
            let jl_size = eval["size"].as_i64().unwrap() as i32;
            assert!(result.is_valid(), "MaxCut should always be valid");
            assert_eq!(
                result.unwrap(),
                jl_size,
                "MaxCut size mismatch for config {:?}",
                config
            );
        }

        let best = BruteForce::new().find_all_best(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best: HashSet<Vec<usize>> = best.into_iter().collect();
        assert_eq!(rust_best, jl_best, "MaxCut best solutions mismatch");
    }
}

#[test]
fn test_jl_parity_qubo_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../data/jl_qubo.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let jl_matrix: Vec<Vec<f64>> = instance["instance"]["matrix"]
            .as_array()
            .unwrap()
            .iter()
            .map(|row| {
                row.as_array()
                    .unwrap()
                    .iter()
                    .map(|v| v.as_i64().unwrap() as f64)
                    .collect()
            })
            .collect();

        // Julia QUBO uses full symmetric matrix: sum(Q_ij * x_i * x_j) for all (i,j)
        // Rust QUBO uses upper triangle only: sum(Q_ij * x_i * x_j) for j >= i
        // Convert: for i < j, Q_rust[i][j] = Q_jl[i][j] + Q_jl[j][i]
        let n = jl_matrix.len();
        let mut rust_matrix = vec![vec![0.0f64; n]; n];
        for i in 0..n {
            rust_matrix[i][i] = jl_matrix[i][i];
            for j in (i + 1)..n {
                rust_matrix[i][j] = jl_matrix[i][j] + jl_matrix[j][i];
            }
        }
        let problem = QUBO::from_matrix(rust_matrix);

        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let result: SolutionSize<f64> = Problem::evaluate(&problem, &config);
            let jl_size = eval["size"].as_i64().unwrap() as f64;
            assert!(result.is_valid(), "QUBO should always be valid");
            assert!(
                (result.unwrap() - jl_size).abs() < 1e-10,
                "QUBO value mismatch for config {:?}: jl={}",
                config,
                jl_size
            );
        }

        let best = BruteForce::new().find_all_best(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best: HashSet<Vec<usize>> = best.into_iter().collect();
        assert_eq!(rust_best, jl_best, "QUBO best solutions mismatch");
    }
}

#[test]
fn test_jl_parity_satisfiability_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../data/jl_satisfiability.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let (num_vars, clauses) = parse_sat_clauses(&instance["instance"]);
        let problem = Satisfiability::new(num_vars, clauses);
        let num_clauses = instance["instance"]["clauses"].as_array().unwrap().len();

        // For SAT: Julia uses EXTREMA mode (counts satisfied clauses, always valid)
        // Rust uses bool (true iff ALL clauses satisfied)
        // Parity check: Rust true ⟺ Julia size == num_clauses
        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let rust_result = problem.evaluate(&config);
            let jl_size = eval["size"].as_u64().unwrap() as usize;
            let jl_all_satisfied = jl_size == num_clauses;
            assert_eq!(
                rust_result, jl_all_satisfied,
                "SAT eval mismatch for config {:?}: rust={}, jl_size={}/{}",
                config, rust_result, jl_size, num_clauses
            );
        }

        // best_solutions from Julia = configs maximizing satisfied clauses
        // For satisfiable formulas, these are exactly the satisfying assignments
        let rust_best = BruteForce::new().find_all_satisfying(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best_set: HashSet<Vec<usize>> = rust_best.into_iter().collect();
        assert_eq!(
            rust_best_set, jl_best,
            "SAT best solutions mismatch"
        );
    }
}

#[test]
fn test_jl_parity_ksatisfiability_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../data/jl_ksatisfiability.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let (num_vars, clauses) = parse_sat_clauses(&instance["instance"]);
        let num_clauses = instance["instance"]["clauses"].as_array().unwrap().len();
        let problem = KSatisfiability::<3>::new(num_vars, clauses);

        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let rust_result = problem.evaluate(&config);
            let jl_size = eval["size"].as_u64().unwrap() as usize;
            let jl_all_satisfied = jl_size == num_clauses;
            assert_eq!(
                rust_result, jl_all_satisfied,
                "KSat eval mismatch for config {:?}",
                config
            );
        }

        let rust_best = BruteForce::new().find_all_satisfying(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best_set: HashSet<Vec<usize>> = rust_best.into_iter().collect();
        assert_eq!(rust_best_set, jl_best, "KSat best solutions mismatch");
    }
}

#[test]
fn test_jl_parity_vertexcovering_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../data/jl_vertexcovering.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let nv = instance["instance"]["num_vertices"].as_u64().unwrap() as usize;
        let edges = parse_edges(&instance["instance"]);
        let weights = parse_i32_vec(&instance["instance"]["weights"]);

        let problem = if weights.iter().all(|&w| w == 1) {
            MinimumVertexCover::<SimpleGraph, i32>::new(nv, edges)
        } else {
            MinimumVertexCover::with_weights(nv, edges, weights)
        };

        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let result = problem.evaluate(&config);
            let jl_valid = eval["is_valid"].as_bool().unwrap();
            assert_eq!(
                result.is_valid(),
                jl_valid,
                "VC validity mismatch for config {:?}",
                config
            );
            if jl_valid {
                let jl_size = eval["size"].as_i64().unwrap() as i32;
                assert_eq!(
                    result.unwrap(),
                    jl_size,
                    "VC size mismatch for config {:?}",
                    config
                );
            }
        }

        let best = BruteForce::new().find_all_best(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best: HashSet<Vec<usize>> = best.into_iter().collect();
        assert_eq!(rust_best, jl_best, "VC best solutions mismatch");
    }
}

#[test]
fn test_jl_parity_setpacking_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../data/jl_setpacking.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let sets = parse_sets(&instance["instance"]["sets"]);
        let weights = parse_i32_vec(&instance["instance"]["weights"]);

        let problem = if weights.iter().all(|&w| w == 1) {
            MaximumSetPacking::<i32>::new(sets)
        } else {
            MaximumSetPacking::with_weights(sets, weights)
        };

        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let result = problem.evaluate(&config);
            let jl_valid = eval["is_valid"].as_bool().unwrap();
            assert_eq!(
                result.is_valid(),
                jl_valid,
                "SetPacking validity mismatch for config {:?}",
                config
            );
            if jl_valid {
                let jl_size = eval["size"].as_i64().unwrap() as i32;
                assert_eq!(
                    result.unwrap(),
                    jl_size,
                    "SetPacking size mismatch for config {:?}",
                    config
                );
            }
        }

        let best = BruteForce::new().find_all_best(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best: HashSet<Vec<usize>> = best.into_iter().collect();
        assert_eq!(rust_best, jl_best, "SetPacking best solutions mismatch");
    }
}

#[test]
fn test_jl_parity_matching_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../data/jl_matching.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let nv = instance["instance"]["num_vertices"].as_u64().unwrap() as usize;
        let weighted_edges = parse_weighted_edges(&instance["instance"]);

        let problem = MaximumMatching::<SimpleGraph, i32>::new(nv, weighted_edges);

        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let result = problem.evaluate(&config);
            let jl_valid = eval["is_valid"].as_bool().unwrap();
            assert_eq!(
                result.is_valid(),
                jl_valid,
                "Matching validity mismatch for config {:?}",
                config
            );
            if jl_valid {
                let jl_size = eval["size"].as_i64().unwrap() as i32;
                assert_eq!(
                    result.unwrap(),
                    jl_size,
                    "Matching size mismatch for config {:?}",
                    config
                );
            }
        }

        let best = BruteForce::new().find_all_best(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best: HashSet<Vec<usize>> = best.into_iter().collect();
        assert_eq!(rust_best, jl_best, "Matching best solutions mismatch");
    }
}

#[test]
fn test_jl_parity_factoring_evaluation() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../data/jl_factoring.json")).unwrap();

    for instance in data["instances"].as_array().unwrap() {
        let m = instance["instance"]["m"].as_u64().unwrap() as usize;
        let n = instance["instance"]["n"].as_u64().unwrap() as usize;
        let input = instance["instance"]["input"].as_u64().unwrap();
        let problem = Factoring::new(m, n, input);

        // Julia Factoring: SolutionSize(0, true) if factors match, SolutionSize(0, false) otherwise
        // Rust Factoring: SolutionSize::Valid(|a*b - target|)
        // Parity: Julia is_valid=true ⟺ Rust value() == 0
        for eval in instance["evaluations"].as_array().unwrap() {
            let config = parse_config(&eval["config"]);
            let result = problem.evaluate(&config);
            let jl_valid = eval["is_valid"].as_bool().unwrap();
            if jl_valid {
                assert_eq!(
                    result.unwrap(),
                    0,
                    "Factoring: valid config {:?} should have distance 0",
                    config
                );
            } else {
                assert_ne!(
                    result.unwrap(),
                    0,
                    "Factoring: invalid config {:?} should have nonzero distance",
                    config
                );
            }
        }

        // Julia findbest returns configs with is_valid=true (product matches)
        // Rust findbest minimizes |a*b - target|, which is 0 for correct factorizations
        let best = BruteForce::new().find_all_best(&problem);
        let jl_best = parse_configs_set(&instance["best_solutions"]);
        let rust_best: HashSet<Vec<usize>> = best.into_iter().collect();
        assert_eq!(rust_best, jl_best, "Factoring best solutions mismatch");
    }
}

// ── Reduction parity tests (with Rust implementations) ──────────────

#[test]
fn test_jl_parity_independentset_to_setpacking() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../data/jl_independentset_to_setpacking.json")).unwrap();

    for case in data["cases"].as_array().unwrap() {
        let jl_best_source = parse_configs_set(&case["best_source"]);
        let jl_extracted_multiple = parse_configs_set(&case["extracted_multiple"]);

        // Reconstruct source from the Petersen graph instance data
        // (same graph as jl_independentset.json)
        let is_data: serde_json::Value =
            serde_json::from_str(include_str!("../data/jl_independentset.json")).unwrap();
        let inst = &is_data["instances"][0]["instance"];
        let nv = inst["num_vertices"].as_u64().unwrap() as usize;
        let edges = parse_edges(inst);
        let source = MaximumIndependentSet::<SimpleGraph, i32>::new(nv, edges);

        // Reduce
        let result = ReduceTo::<MaximumSetPacking<i32>>::reduce_to(&source);
        let target = result.target_problem();

        // Solve both
        let solver = BruteForce::new();
        let best_target = solver.find_all_best(target);
        let best_source = solver.find_all_best(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();

        // Extract solutions
        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();

        // Verify extracted solutions are among best source solutions
        assert!(
            extracted.is_subset(&best_source_set),
            "Extracted solutions should be among best source solutions"
        );

        // Compare with Julia's solutions
        assert_eq!(best_source_set, jl_best_source, "Best source mismatch");
        assert_eq!(
            jl_extracted_multiple, jl_best_source,
            "Julia extracted_multiple should match best_source"
        );
    }
}

#[test]
fn test_jl_parity_setpacking_to_independentset() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../data/jl_setpacking_to_independentset.json")).unwrap();

    for case in data["cases"].as_array().unwrap() {
        let jl_best_source = parse_configs_set(&case["best_source"]);

        // Reconstruct source from setpacking fixture data
        let sp_data: serde_json::Value =
            serde_json::from_str(include_str!("../data/jl_setpacking.json")).unwrap();
        let inst = &sp_data["instances"][0]["instance"];
        let sets = parse_sets(&inst["sets"]);
        let source = MaximumSetPacking::<i32>::new(sets);

        let result = ReduceTo::<MaximumIndependentSet<SimpleGraph, i32>>::reduce_to(&source);
        let target = result.target_problem();

        let solver = BruteForce::new();
        let best_target = solver.find_all_best(target);
        let best_source = solver.find_all_best(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();

        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();

        assert!(extracted.is_subset(&best_source_set));
        assert_eq!(best_source_set, jl_best_source, "Best source mismatch");
    }
}

#[test]
fn test_jl_parity_independentset_to_vertexcovering() {
    let data: serde_json::Value = serde_json::from_str(include_str!(
        "../data/jl_independentset_to_vertexcovering.json"
    ))
    .unwrap();

    for case in data["cases"].as_array().unwrap() {
        let jl_best_source = parse_configs_set(&case["best_source"]);

        let is_data: serde_json::Value =
            serde_json::from_str(include_str!("../data/jl_independentset.json")).unwrap();
        let inst = &is_data["instances"][0]["instance"];
        let nv = inst["num_vertices"].as_u64().unwrap() as usize;
        let edges = parse_edges(inst);
        let source = MaximumIndependentSet::<SimpleGraph, i32>::new(nv, edges);

        let result = ReduceTo::<MinimumVertexCover<SimpleGraph, i32>>::reduce_to(&source);
        let target = result.target_problem();

        let solver = BruteForce::new();
        let best_target = solver.find_all_best(target);
        let best_source = solver.find_all_best(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();

        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();

        assert!(extracted.is_subset(&best_source_set));
        assert_eq!(best_source_set, jl_best_source, "Best source mismatch");
    }
}

#[test]
fn test_jl_parity_vertexcovering_to_setcovering() {
    let data: serde_json::Value = serde_json::from_str(include_str!(
        "../data/jl_vertexcovering_to_setcovering.json"
    ))
    .unwrap();

    for case in data["cases"].as_array().unwrap() {
        let jl_best_source = parse_configs_set(&case["best_source"]);

        let vc_data: serde_json::Value =
            serde_json::from_str(include_str!("../data/jl_vertexcovering.json")).unwrap();
        let inst = &vc_data["instances"][0]["instance"];
        let nv = inst["num_vertices"].as_u64().unwrap() as usize;
        let edges = parse_edges(inst);
        let weights = parse_i32_vec(&inst["weights"]);
        let source = MinimumVertexCover::with_weights(nv, edges, weights);

        let result = ReduceTo::<MinimumSetCovering<i32>>::reduce_to(&source);
        let target = result.target_problem();

        let solver = BruteForce::new();
        let best_target = solver.find_all_best(target);
        let best_source = solver.find_all_best(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();

        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();

        assert!(extracted.is_subset(&best_source_set));
        assert_eq!(best_source_set, jl_best_source, "Best source mismatch");
    }
}

#[test]
fn test_jl_parity_spinglass_to_maxcut() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../data/jl_spinglass_to_maxcut.json")).unwrap();

    for case in data["cases"].as_array().unwrap() {
        let jl_best_source = parse_configs_set(&case["best_source"]);

        let sg_data: serde_json::Value =
            serde_json::from_str(include_str!("../data/jl_spinglass.json")).unwrap();
        let inst = &sg_data["instances"][0]["instance"];
        let nv = inst["num_vertices"].as_u64().unwrap() as usize;
        let edges = parse_edges(inst);
        let j_values = parse_i32_vec(&inst["J"]);
        let h_values = parse_i32_vec(&inst["h"]);

        let interactions: Vec<((usize, usize), i32)> = edges
            .into_iter()
            .zip(j_values)
            .collect();
        let source = SpinGlass::<SimpleGraph, i32>::new(nv, interactions, h_values);

        let result = ReduceTo::<MaxCut<SimpleGraph, i32>>::reduce_to(&source);
        let target = result.target_problem();

        let solver = BruteForce::new();
        let best_target = solver.find_all_best(target);
        let best_source = solver.find_all_best(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();

        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();

        assert!(extracted.is_subset(&best_source_set));
        assert_eq!(best_source_set, jl_best_source, "Best source mismatch");
    }
}

#[test]
fn test_jl_parity_maxcut_to_spinglass() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../data/jl_maxcut_to_spinglass.json")).unwrap();

    for case in data["cases"].as_array().unwrap() {
        let jl_best_source = parse_configs_set(&case["best_source"]);

        let mc_data: serde_json::Value =
            serde_json::from_str(include_str!("../data/jl_maxcut.json")).unwrap();
        let inst = &mc_data["instances"][0]["instance"];
        let nv = inst["num_vertices"].as_u64().unwrap() as usize;
        let weighted_edges = parse_weighted_edges(inst);
        let source = MaxCut::<SimpleGraph, i32>::new(nv, weighted_edges);

        let result = ReduceTo::<SpinGlass<SimpleGraph, i32>>::reduce_to(&source);
        let target = result.target_problem();

        let solver = BruteForce::new();
        let best_target = solver.find_all_best(target);
        let best_source = solver.find_all_best(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();

        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();

        assert!(extracted.is_subset(&best_source_set));
        assert_eq!(best_source_set, jl_best_source, "Best source mismatch");
    }
}

#[test]
fn test_jl_parity_spinglass_to_qubo() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../data/jl_spinglass_to_qubo.json")).unwrap();

    for case in data["cases"].as_array().unwrap() {
        let jl_best_source = parse_configs_set(&case["best_source"]);

        let sg_data: serde_json::Value =
            serde_json::from_str(include_str!("../data/jl_spinglass.json")).unwrap();
        let inst = &sg_data["instances"][0]["instance"];
        let nv = inst["num_vertices"].as_u64().unwrap() as usize;
        let edges = parse_edges(inst);
        let j_values: Vec<f64> = inst["J"]
            .as_array()
            .unwrap()
            .iter()
            .map(|v| v.as_i64().unwrap() as f64)
            .collect();
        let h_values: Vec<f64> = inst["h"]
            .as_array()
            .unwrap()
            .iter()
            .map(|v| v.as_i64().unwrap() as f64)
            .collect();

        let interactions: Vec<((usize, usize), f64)> = edges
            .into_iter()
            .zip(j_values)
            .collect();
        let source = SpinGlass::<SimpleGraph, f64>::new(nv, interactions, h_values);

        let result = ReduceTo::<QUBO<f64>>::reduce_to(&source);
        let target = result.target_problem();

        let solver = BruteForce::new();
        let best_target = solver.find_all_best(target);
        let best_source = solver.find_all_best(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();

        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();

        assert!(extracted.is_subset(&best_source_set));
        assert_eq!(best_source_set, jl_best_source, "Best source mismatch");
    }
}

#[test]
fn test_jl_parity_qubo_to_spinglass() {
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../data/jl_qubo_to_spinglass.json")).unwrap();

    for case in data["cases"].as_array().unwrap() {
        let jl_best_source = parse_configs_set(&case["best_source"]);

        let q_data: serde_json::Value =
            serde_json::from_str(include_str!("../data/jl_qubo.json")).unwrap();
        let jl_matrix: Vec<Vec<f64>> = q_data["instances"][0]["instance"]["matrix"]
            .as_array()
            .unwrap()
            .iter()
            .map(|row| {
                row.as_array()
                    .unwrap()
                    .iter()
                    .map(|v| v.as_i64().unwrap() as f64)
                    .collect()
            })
            .collect();
        // Convert Julia full-matrix to Rust upper-triangle convention
        let n = jl_matrix.len();
        let mut rust_matrix = vec![vec![0.0f64; n]; n];
        for i in 0..n {
            rust_matrix[i][i] = jl_matrix[i][i];
            for j in (i + 1)..n {
                rust_matrix[i][j] = jl_matrix[i][j] + jl_matrix[j][i];
            }
        }
        let source = QUBO::from_matrix(rust_matrix);

        let result = ReduceTo::<SpinGlass<SimpleGraph, f64>>::reduce_to(&source);
        let target = result.target_problem();

        let solver = BruteForce::new();
        let best_target = solver.find_all_best(target);
        let best_source = solver.find_all_best(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();

        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();

        assert!(extracted.is_subset(&best_source_set));
        assert_eq!(best_source_set, jl_best_source, "Best source mismatch");
    }
}

#[test]
fn test_jl_parity_sat_to_ksat() {
    let data: serde_json::Value = serde_json::from_str(include_str!(
        "../data/jl_satisfiability_to_ksatisfiability3.json"
    ))
    .unwrap();

    for case in data["cases"].as_array().unwrap() {
        let jl_best_source = parse_configs_set(&case["best_source"]);

        let sat_data: serde_json::Value =
            serde_json::from_str(include_str!("../data/jl_satisfiability.json")).unwrap();
        let inst = &sat_data["instances"][0]["instance"];
        let (num_vars, clauses) = parse_sat_clauses(inst);
        let source = Satisfiability::new(num_vars, clauses);

        let result = ReduceTo::<KSatisfiability<3>>::reduce_to(&source);
        let target = result.target_problem();

        let solver = BruteForce::new();
        let best_target = solver.find_all_satisfying(target);
        let best_source = solver.find_all_satisfying(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();

        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();

        assert!(extracted.is_subset(&best_source_set));
        assert_eq!(best_source_set, jl_best_source, "Best source mismatch");
    }
}

#[test]
fn test_jl_parity_ksat_to_sat() {
    let data: serde_json::Value = serde_json::from_str(include_str!(
        "../data/jl_ksatisfiability_to_satisfiability.json"
    ))
    .unwrap();

    for case in data["cases"].as_array().unwrap() {
        let jl_best_source = parse_configs_set(&case["best_source"]);

        let ksat_data: serde_json::Value =
            serde_json::from_str(include_str!("../data/jl_ksatisfiability.json")).unwrap();
        let inst = &ksat_data["instances"][0]["instance"];
        let (num_vars, clauses) = parse_sat_clauses(inst);
        let source = KSatisfiability::<3>::new(num_vars, clauses);

        let result = ReduceTo::<Satisfiability>::reduce_to(&source);
        let target = result.target_problem();

        let solver = BruteForce::new();
        let best_target = solver.find_all_satisfying(target);
        let best_source = solver.find_all_satisfying(&source);
        let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();

        let extracted: HashSet<Vec<usize>> = best_target
            .iter()
            .map(|t| result.extract_solution(t))
            .collect();

        assert!(extracted.is_subset(&best_source_set));
        assert_eq!(best_source_set, jl_best_source, "Best source mismatch");
    }
}

#[test]
fn test_jl_parity_circuitsat_to_spinglass() {
    // CircuitSAT is complex to reconstruct from JSON, so we just verify the
    // Rust reduction produces consistent results (closed-loop test).
    // Build the same circuit as in the Julia test:
    //   x = a ∨ ¬b
    //   y = ¬c ∨ b
    //   z = x ∧ y ∧ a
    let a = BooleanExpr::var("a");
    let b = BooleanExpr::var("b");
    let c = BooleanExpr::var("c");

    let x_expr = BooleanExpr::or(vec![a.clone(), BooleanExpr::not(b.clone())]);
    let y_expr = BooleanExpr::or(vec![BooleanExpr::not(c.clone()), b.clone()]);
    let z_expr = BooleanExpr::and(vec![
        BooleanExpr::var("x"),
        BooleanExpr::var("y"),
        a.clone(),
    ]);

    let circuit = Circuit::new(vec![
        Assignment::new(vec!["x".to_string()], x_expr),
        Assignment::new(vec!["y".to_string()], y_expr),
        Assignment::new(vec!["z".to_string()], z_expr),
    ]);
    let source = CircuitSAT::new(circuit);

    let result = ReduceTo::<SpinGlass<SimpleGraph, i32>>::reduce_to(&source);
    let target = result.target_problem();

    let solver = BruteForce::new();
    let best_target = solver.find_all_best(target);
    let best_source = solver.find_all_satisfying(&source);

    // Extract and verify
    let extracted: HashSet<Vec<usize>> = best_target
        .iter()
        .map(|t| result.extract_solution(t))
        .collect();

    let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();
    assert!(
        extracted.is_subset(&best_source_set),
        "CircuitSAT→SpinGlass: extracted solutions should be satisfying"
    );
}

#[test]
fn test_jl_parity_factoring_to_circuitsat() {
    // Verify Factoring(1,1,1) → CircuitSAT reduction
    let source = Factoring::new(1, 1, 1);

    let result = ReduceTo::<CircuitSAT>::reduce_to(&source);
    let target = result.target_problem();

    let solver = BruteForce::new();
    let best_target = solver.find_all_satisfying(target);

    // Extract solutions back
    let extracted: Vec<Vec<usize>> = best_target
        .iter()
        .map(|t| result.extract_solution(t))
        .collect();

    // Verify all extracted solutions are valid factorizations
    for sol in &extracted {
        let eval = source.evaluate(sol);
        assert_eq!(
            eval.unwrap(),
            0,
            "Factoring extracted solution {:?} should be valid",
            sol
        );
    }

    // Check Julia fixture data
    let data: serde_json::Value =
        serde_json::from_str(include_str!("../data/jl_factoring_to_circuitsat.json")).unwrap();
    let jl_best_source = parse_configs_set(&data["cases"][0]["best_source"]);

    let best_source = BruteForce::new().find_all_best(&source);
    let best_source_set: HashSet<Vec<usize>> = best_source.into_iter().collect();
    assert_eq!(
        best_source_set, jl_best_source,
        "Factoring best source mismatch"
    );
}

// ── Reduction parity tests (NOT yet implemented in Rust) ────────────

#[test]
#[ignore] // SAT → Coloring{3} not yet implemented in Rust
fn test_jl_parity_sat_to_coloring() {}

#[test]
#[ignore] // SAT → IndependentSet not yet implemented in Rust
fn test_jl_parity_sat_to_independentset() {}

#[test]
#[ignore] // SAT → DominatingSet not yet implemented in Rust
fn test_jl_parity_sat_to_dominatingset() {}

#[test]
#[ignore] // Matching → SetPacking not yet implemented in Rust
fn test_jl_parity_matching_to_setpacking() {}
